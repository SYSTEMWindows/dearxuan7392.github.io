{"meta":{"title":"DearXuan的主页","subtitle":"","description":"欢迎访问DearXuan的主页!","author":"DearXuan","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-08-19T13:41:53.000Z","updated":"2021-08-19T13:41:53.448Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-19T13:40:38.000Z","updated":"2021-08-19T13:40:38.593Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-19T13:41:45.000Z","updated":"2021-08-19T13:41:45.971Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用RSA加密实现的简易离线验证功能(C#,含代码)","slug":"用RSA加密实现的简易离线验证功能","date":"2021-08-20T02:44:58.000Z","updated":"2021-08-20T02:51:48.577Z","comments":true,"path":"2021/08/20/用RSA加密实现的简易离线验证功能/","link":"","permalink":"http://example.com/2021/08/20/%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"许多软件都有正版验证功能，它们通常需要联网验证，验证的本质则是加密与解密，本文将使用RSA加密算法实现简易的离线验证功能 RSA加密设p,q是两个超级大的素数，N=pq，数据通过欧拉函数φ(N)来加密，而欧拉函数φ(N)满足φ(N)= φ(pq)=(p-1)(q-1)，如果要算出φ(N)，就必须知道p和q。并且这有一点好处，某人可以公开宣布他的密钥e以及N，任何人都可以给他发送密文，但是只有他能看懂。因为想要破解密码，就必须知道那两个超级大素数p,q.p和q的位数决定了密文的安全性。 硬件绑定由于是离线验证，所以我们能很容易想到可以根据电脑的硬件信息生成一串加密字符串，程序根据加密字符串解密出硬件信息，如果解密出来的信息与实际电脑配置信息相同，则认为验证通过。同时我们还可以在字符串上添加一些额外信息，例如有效期，这样就能做到限定时间的功能。这里以BIOS为例，使用ManagementClass和ManagementObjectCollection读取硬件信息，注意这两个类的命名空间为System.Management 123456789101112131415161718192021ManagementClass mc = null;ManagementObjectCollection moc = null;try{ mc = new ManagementClass(\"Win32_BIOS\"); moc = mc.GetInstances(); foreach (ManagementObject mo in moc) { bios = mo.Properties[\"SerialNumber\"].Value.ToString(); break; }}catch(Exception ex){ bios = null;}finally{ if (mc != null) mc.Dispose(); if (moc != null) moc.Dispose();} 程序读取了BIOS编号，并保存在bios字符串中现在根据BIOS编号生成密文，C#提供了RSACryptoServiceProvider来帮助加密，注意这个类的命名空间为System.Security.Cryptography 12345678910111213141516171819public static string Encrypt(string content){ string publickey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(publickey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false); return Convert.ToBase64String(cipherbytes);} public static string Decrypt(string content){ string privatekey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/hf2dnK7rNfl3lbqghWcpFdu778hUpIEBixCDL5WiBtpkZdpSw90aERmHJYaW2RGvGRi6zSftLh00KHsPcNUMw==&lt;/P&gt;&lt;Q&gt;6Cn/jOLrPapDTEp1Fkq+uz++1Do0eeX7HYqi9rY29CqShzCeI7LEYOoSwYuAJ3xA/DuCdQENPSoJ9KFbO4Wsow==&lt;/Q&gt;&lt;DP&gt;ga1rHIJro8e/yhxjrKYo/nqc5ICQGhrpMNlPkD9n3CjZVPOISkWF7FzUHEzDANeJfkZhcZa21z24aG3rKo5Qnw==&lt;/DP&gt;&lt;DQ&gt;MNGsCB8rYlMsRZ2ek2pyQwO7h/sZT8y5ilO9wu08Dwnot/7UMiOEQfDWstY3w5XQQHnvC9WFyCfP4h4QBissyw==&lt;/DQ&gt;&lt;InverseQ&gt;EG02S7SADhH1EVT9DD0Z62Y0uY7gIYvxX/uq+IzKSCwB8M2G7Qv9xgZQaQlLpCaeKbux3Y59hHM+KpamGL19Kg==&lt;/InverseQ&gt;&lt;D&gt;vmaYHEbPAgOJvaEXQl+t8DQKFT1fudEysTy31LTyXjGu6XiltXXHUuZaa2IPyHgBz0Nd7znwsW/S44iql0Fen1kzKioEL3svANui63O3o5xdDeExVM6zOf1wUUh/oldovPweChyoAdMtUzgvCbJk1sYDJf++Nr0FeNW1RB1XG30=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privatekey); cipherbytes = rsa.Decrypt(Convert.FromBase64String(content), false); return Encoding.UTF8.GetString(cipherbytes);} 两部分核心代码已经完成，在程序中先获取BIOS编号，然后提示用户输入许可证，这个许可证实际上就是密文，程序解密密文，这里需要注意的是，如果用户输入的密文格式有误，则解密函数会抛出异常，因此需要套上try来执行，如果发生异常，则一律认为验证失败。以下是程序界面 文件读写验证模块已经完成，但是每次打开都要用户手动输入许可证，及其繁琐，因此我们需要将许可证保存在本地。首先在D盘创建ducuments目录，在document里创建LICENSE文件，注意需引入命名空间System.IO定义地址 123private static string dirname = @\"D:\\documents\";private static string filename = \"LICENSE.dx\";private static string path = System.IO.Path.Combine(dirname, filename); 创建目录和文件，这里需注意Create后必须dispose，否则接下来读取时会提示被占用 123456System.IO.Directory.CreateDirectory(dirname);if (!File.Exists(path)){ FileStream fileStream = System.IO.File.Create(path); fileStream.Dispose();} 读取和写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static string ReadFile(){ string key = \"\"; string line; StreamReader sr = null; try { sr = new StreamReader(path); while ((line = sr.ReadLine()) != null) { key += line; } } catch(Exception ex) { key = null; } finally { if(sr != null) { sr.Dispose(); } } return key;} public static void WriteFile(string key){ StreamWriter sw = null; try { sw = new StreamWriter(path); sw.Write(key); } catch (Exception ex) { } finally { if (sw != null) { sw.Dispose(); } }} StreamReader和StreamWriter可以放在using里面执行，这样就会自动销毁，但是为了显示dispose的重要性，本程序中手动disposeStreamReader将许可证以文本形式写入文件里，而读取也是文本形式读取，所以文件的后缀名可以随便取。","categories":[],"tags":[],"author":"DearXuan"},{"title":"PVZ逆向分析与C#内存操作(含源文件)","slug":"PVZ逆向分析与C-内存操作","date":"2021-07-19T11:03:00.000Z","updated":"2021-08-20T03:22:10.450Z","comments":true,"path":"2021/07/19/PVZ逆向分析与C-内存操作/","link":"","permalink":"http://example.com/2021/07/19/PVZ%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%8EC-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/","excerpt":"","text":"首先打开植物大战僵尸，进入游戏，初始阳光为50.打开CE修改器，搜索50进入游戏，种植向日葵，阳光变成0，再次搜索再进入游戏，收取阳光，阳光变成25，搜索25显然地址0x144344C8保存的就是阳光，现在退出游戏重新打开，重复上面步骤现在地址变成0x1408EDC0了，说明阳光的地址并不是固定的。对这个地址进行检测，查看是哪条指令在修改我刚刚进行了种植和收集阳光两个步骤，显然mov是减少阳光，add是增加阳光。查看详细信息得到EAX = 0x14089860，这个0x5560其实就是二级偏移.然而EAX也是动态变化的，我们需要在内存中搜索EAX，来查找它到底保存在哪个地方由于这个地址保存了阳光的地址，所以它应该是不变的，否则就找不到阳光的地址了，所以可以多次重复扫描，确保把会改变的量排除。逐一查看哪个操作码访问了上面地址，发现地址0x028CA730很有趣列表里清一色的都是0x768，证明[EAX + 0x028CA730]保存了结构体地址，查看EAX地址这里不管是查看EAX还是ECX，结果肯定是一样的，因为它们都指向同一个地址，且偏移也相同。EAX = 0x028C9FC8，而0x768就是一级偏移。继续搜索EAX列表里出现绿色的基址，查找结束。开始写代码，C#无法直接修改内存，需要动态调用kernel32.dll 1234567891011[DllImport(\"kernel32.dll\", EntryPoint = \"OpenProcess\")]public static extern IntPtr OpenProcess(int desiredAccess, bool heritHandle, int pocessID); [DllImport(\"kernel32.dll\", EntryPoint = \"CloseHandle\")]public static extern void CloseHandle(IntPtr hObject); [DllImport(\"kernel32.dll\", EntryPoint = \"ReadProcessMemory\")]public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr baseaddress, IntPtr buffer, int nsize, IntPtr bytesread); [DllImport(\"kernel32.dll\", EntryPoint = \"WriteProcessMemory\")]public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr baseaddress, long[] buffer, int nSize, IntPtr byteswrite); 读写内存需要用到OpenProcess，官方文档里告诉我们第一个参数是访问权限，PROCESS_ALL_ACCESS指所有能获得的最高权限，但是PROCESS_ALL_ACCESS是在C++里定义的，C#里却没有，注意到这个值的类型是int，我们可以在C++里打印出这个值，然后直接写在C#里所以我们只要输入0x1F0FFF就行了 123456789101112131415private int ReadMemory(int pid,IntPtr toBase){ byte[] bytes = new byte[4]; IntPtr address = Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0); IntPtr process = OpenProcess(0x1F0FFF, false, pid); ReadProcessMemory(process, toBase, address, 4, IntPtr.Zero); CloseHandle(process); return Marshal.ReadInt32(address);}private void WriteMemory(int pid,IntPtr toBase,int num){ IntPtr process = OpenProcess(0x1F0FFF, false, pid); WriteProcessMemory(process, toBase, new long[] { num }, 4, IntPtr.Zero); CloseHandle(process);} 获取进程PID 123456789101112131415private int GetPid(){ Process[] processes = Process.GetProcessesByName(ProcessName); if(processes.Length == 0) { ShowDialog(\"没有检测到游戏进程.\"); return -1; } if(processes.Length &gt; 1) { ShowDialog(\"检测到多个进程，这可能是因为您开启了多个相同进程名的软件，请关闭多余软件.\"); return -1; } return processes[0].Id;} 定义全局变量 12345private const string ProcessName = \"PlantsVsZombies\";//进程名称private const int sun = 9990;//每次修改的阳光数值 private int pid;//进程PIDprivate IntPtr intPtr;//阳光的地址 获取进程信息 12345678private void GetInfo(){ pid = GetPid(); if (pid == -1) return; int num1 = ReadMemory(pid, (IntPtr)0x006A9EC0); int num2 = ReadMemory(pid, (IntPtr)(num1 + 0x768)); intPtr = (IntPtr)(num2 + 0x5560);} 添加两个按钮，第一个按钮用来读取进程信息，第二个按钮用来修改阳光 12345678private void button1_Click(object sender, EventArgs e){ GetInfo();}private void button2_Click(object sender, EventArgs e){ WriteMemory(pid, intPtr, sun);} 修改成功关闭植物大战僵尸，重新打开，再次尝试。修改成功，修改器制作完成。接下来是优化MemoryIO.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks; namespace PVZ_Cheater{ static class MemoryIO { [DllImport(\"kernel32.dll\", EntryPoint = \"OpenProcess\")] public static extern IntPtr OpenProcess(int desiredAccess, bool heritHandle, int pocessID); [DllImport(\"kernel32.dll\", EntryPoint = \"CloseHandle\")] public static extern void CloseHandle(IntPtr hObject); [DllImport(\"kernel32.dll\", EntryPoint = \"ReadProcessMemory\")] public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr baseaddress, IntPtr buffer, int nsize, IntPtr bytesread); [DllImport(\"kernel32.dll\", EntryPoint = \"WriteProcessMemory\")] public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr baseaddress, long[] buffer, int nSize, IntPtr byteswrite); public static int GetPid(string ProcessName) { Process[] processes = Process.GetProcessesByName(ProcessName); if (processes.Length == 0) { throw new Exception(\"没有检测到游戏进程.\"); } if (processes.Length &gt; 1) { throw new Exception(\"检测到多个进程，这可能是因为您开启了多个相同进程名的软件，请关闭多余软件.\"); } return processes[0].Id; } public static int ReadMemory(int pid, IntPtr toBase) { byte[] bytes = new byte[4]; IntPtr address = Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0); IntPtr process = OpenProcess(0x1F0FFF, false, pid); ReadProcessMemory(process, toBase, address, 4, IntPtr.Zero); CloseHandle(process); return Marshal.ReadInt32(address); } public static void WriteMemory(int pid, IntPtr toBase, int num) { IntPtr process = OpenProcess(0x1F0FFF, false, pid); WriteProcessMemory(process, toBase, new long[] { num }, 4, IntPtr.Zero); CloseHandle(process); } }} PVZInfo.cs 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms; namespace PVZ_Cheater{ static class PVZInfo { public const string ProcessName = \"PlantsVsZombies\"; public static int Pid; public static IntPtr Sun_Address; public static int Sun_Value = 9990; public static bool isReady = false; public static void GetInfo() { isReady = false; Pid = MemoryIO.GetPid(ProcessName); int num1 = MemoryIO.ReadMemory(Pid, (IntPtr)0x006A9EC0); int num2 = MemoryIO.ReadMemory(Pid, (IntPtr)(num1 + 0x768)); Sun_Address = (IntPtr)(num2 + 0x5560); isReady = true; } public static void SetSun() { if(isReady) MemoryIO.WriteMemory(Pid, Sun_Address, Sun_Value); } }} 增加一个Timer计时器，当选中”锁定阳光”选项时，每隔1秒将阳光赋值为9990，成功实现无限阳光 源文件:https://dearx.lanzoui.com/ibVLJrm95be","categories":[{"name":"底层","slug":"底层","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82/"},{"name":"内存","slug":"底层/内存","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82/%E5%86%85%E5%AD%98/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"C#序列化对象的二进制储存方法及底层原理研究","slug":"C-序列化对象的二进制储存方法及底层原理研究","date":"2021-07-19T01:55:00.000Z","updated":"2021-08-20T03:09:57.068Z","comments":true,"path":"2021/07/19/C-序列化对象的二进制储存方法及底层原理研究/","link":"","permalink":"http://example.com/2021/07/19/C-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%82%A8%E5%AD%98%E6%96%B9%E6%B3%95%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/","excerpt":"","text":"在硬盘里保存txt或二进制文件非常容易，当需要保存的对象是一个自定义类的对象时，此时采用txt或二进制存储都较为复杂，如果采用txt形式，那么在保存非文本的数据时，需要手动转换，并且txt非常容易修改。保存为二进制文件较为简单，C#还提供了int32,byte等类型的读写方法，可以直接使用，但是仍有弊端，即代码复杂，你需要不断地读取，赋值。 实际上C#提供了序列化存储的方法，可以轻松地把一个对象保存到硬盘里。 首先定义一个类，并在最前面加上”[Serializable]”，表示这个类可以序列化 12345678[Serializable]class Struct{ public string a { get; set; } public string b { get; set; } public int s { get; set; } } 引入命名空间System.Runtime.Serialization.Formatters.Binary和System.IO 实例化对象@struct，并保存在D:\\abc.txt 123456789101112static void Save(){ Struct @struct = new Struct(); @struct.a = \"123\"; @struct.b = \"ABCD\"; @struct.s = 27; using (FileStream fileStream = new FileStream(@\"D:\\abc.txt\", FileMode.OpenOrCreate)) { BinaryFormatter binaryFormatter = new BinaryFormatter(); binaryFormatter.Serialize(fileStream, @struct); }} 从硬盘读取 1234567891011static void Read(){ using(FileStream fileStream = new FileStream(@\"D:\\abc.txt\", FileMode.OpenOrCreate)) { BinaryFormatter binaryFormatter = new BinaryFormatter(); Struct @struct = binaryFormatter.Deserialize(fileStream) as Struct; Console.WriteLine(@struct.a); Console.WriteLine(@struct.b); Console.WriteLine(@struct.s); }} 运行结果 现在开始研究底层原理 首先给这个类加上一个变量k 12345678910[Serializable]class Struct{ public string a { get; set; } public string b { get; set; } public int s { get; set; } public int k { get; set; } } 执行Read方法，发现竟然读取成功了，但是k并没有被赋值 我们再给他加上一个方法ABC 1234567891011121314class Struct{ public string a { get; set; } public string b { get; set; } public int s { get; set; } public int k { get; set; } public void ABC() { k++; } } 现在这个类的结果已经完全改变，但是执行了Read方法后发现仍然读取成功了。 现在我们修改其中一个变量名，把s改成ss 12345678[Serializable]class Struct{ public string a { get; set; } public string b { get; set; } public int ss { get; set; } } 执行结果 最后我们把类名Struct改成Struct1\\ 12345678[Serializable]class Struct1{ public string a { get; set; } public string b { get; set; } public int s { get; set; } } 不出所料地失败了 到这里已经基本可以看出序列化储存地原理，C#采用了类似XML文件地方法，将类名，变量名与变量值保存到一起。 将保存的文件以二进制形式打开 搜索字符串”123” 发现就在这个字符串的后面出现了连续的41到45，很明显这就是”ABCDE”的ASCII码，只不过是16进制的，换成10进制就看着舒服多了 同时我们还注意到这些字符串的前面都有一个数字恰好是后面的字符串长度 例如: “03”代表后面3个字节是字符串，但是为什么”03”前面还有3个”00”？在VS里随意输入一个字符串.Length，查看Length的类型 Length返回的是int类型，这说明string的最大长度不会超过int的最大值，int是int32的别名，从名字就能看出int32占了32位，恰好是4个字节，这也证明string的储存形式是 “长度+内容” 继续往后看，最后面还有一个int类型的数字27，但是这个27的位置很奇怪，他居然是靠左的，而刚刚还是靠右的。为了进一步研究，我们把27改成999999999 现在的十六进制码是 FF C9 9A 3B。通过其他软件进制转换，发现正确的十六进制码应该是 3B 9A C9 FF。恰好是上面的反转。 我们再把int改成long，并把数字改成99999999999999999，再次尝试。 软件中是：FF FF 89 5D 78 45 63 01 实际上是：01 63 45 78 5D 89 FF FF 已经足够肯定C#会将数字倒序输出。但是这样不是多此一举吗？大家是否还记得在进制转换时需要不断计算余数，最后把余数倒序排列？并且这个规律只在16进制出现，合理猜测C#在保存数值类型数据时会把数字转化成16进制来保存，并且没有倒序输出。而十六进制转十进制时，也是需要从右往左来读取，第一个数的权值是1，第二个数是16，第三个是16^2。不管是保存还是读取，都是需要从右往左的，因为右边是最低位。 生活中进制转换需要把余数倒序排列，因为我们的数字是高位在左，低位在右，而计算机储存时显然不需要遵守这个规律，它可以令高位在右，低位在左，这样就省去了倒序输出这一步，并且也符合了文件流操作从左到右的顺序。 至于为什么选择16进制，而不是二进制，可能是为了效率，同样的一个数2^16，如果除以16，则只需要计算4次，但是如果除以2，则需要计算16次，效率相差了4倍。但是最终不是还要用二进制保存吗？是不是还需要把16进制转成2进制？如果是我们自己写代码，可能真的需要多转换一次，但是计算机是以2进制保存数据，除法的底层原理是位移计算，计算结果也是2进制数，所以计算机并不需要额外转换一次。 想到这里，看似已经真相大白，但是又出现了新的问题，我们输入的数字在内存里也是二进制形式，计算机可以直接把这个二进制形式的数字从左到右保存到文件里，为什么要多此一举先转换成10进制，再转成16进制？ 接下来我们用C++进行下一步实验 图中可以看到，我在计算机中保存了0x11223344这个数字，尽管我输入的是16进制，但是内存里仍然是按int类型储存。C++中的char只占了一个字节，所以我们定义一个char指针，把他指向a，此时p指向的是a的第一个字节，顺序打印p,p+1,p+2,p+3位置的数据，发现结果是 44 33 22 11。 这样的结果与我们的输入完全相反，但同时也证明了int在内存中是倒序存放的(相对于人类是倒序)。与上面的猜想相联系，最终得出答案：数字在内存中是以字节为单位倒序保存的，这样保存的优点在于可以从低位到高位的读取方向与流操作从左到右的方向相同，加快了读取速度。 最后回到一开始的问题上来，我们已经研究了变量在序列化操作中的保存方法。如果刚刚仔细观察，会发现文件末尾总是 0B，由此我们可以大胆猜测这是结束符。我们还发现字符串的前面除了有四个字节用来表示数字以外，还有两个字节 06 03，以及第二个字符串前面的 06 04，如果你在类里面多定义一个字符串，你会发现字节码里多出一个 06 05，因此我们也可以大胆猜测这是字符串标志。为了进一步验证这个猜想，我们把前面的0603改成0604，把后面的0604改成0603，重新读取，发现能够正常读取，而如果把前面的06改成07，就无法读取了，可以证明06是标识符。后面的数据是按顺序存储的，而不是采用指针的方法。 到这里已经基本搞清楚变量的储存结构了，前面一长串的字节可以直接用txt格式打开，能够发现其中夹杂着Version,PublicKeyToken,Struct等，这些数据表明了版本，类的结构，类里面的变量名等数据，用来判断类的格式。后面紧跟着的是变量，变量与前面的变量名按顺序一一对应，最后一位是0B，表示文件流结束。","categories":[{"name":"底层原理","slug":"底层原理","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"二进制","slug":"底层原理/二进制","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"C#实现简易XML阅读器(含源文件和exe文件)","slug":"C-实现简易XML阅读器","date":"2021-07-14T13:01:00.000Z","updated":"2021-08-20T03:11:11.131Z","comments":true,"path":"2021/07/14/C-实现简易XML阅读器/","link":"","permalink":"http://example.com/2021/07/14/C-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93XML%E9%98%85%E8%AF%BB%E5%99%A8/","excerpt":"","text":"功能本程序的主要目的是便于阅读XML文件。在网上复制一些XML文本时，常常出现格式错误，更有甚者，整个文本就一行，一行有几百个字符。这些奇奇怪怪的格式大大增加了理解难度，本程序将模仿记事本，提供基础的文件读写，编辑功能，并在此基础上增加了格式对齐和高亮功能。 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;Class&gt; &lt;Student&gt; &lt;ID&gt;1111&lt;/ID&gt; &lt;name&gt;Happy&lt;/name&gt; &lt;/Student&gt; &lt;Student&gt; &lt;ID&gt;2222&lt;/ID&gt; &lt;name&gt;Sad&lt;/name&gt; &lt;/Student&gt; &lt;/Class&gt; 界面设计主界面分为菜单栏和输入框 文件读写新建FileIO.cs，引入命名空间System.IO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static class FileIO{ public static string ReadFile(string path) { if (path == null) return null; string line; string s = \"\"; StreamReader streamReader = null; try { streamReader = new StreamReader(path); while((line = streamReader.ReadLine()) != null) { s += line + \"\\n\"; } } catch(Exception ex) { s = null; } finally { if (streamReader != null) streamReader.Dispose(); } return s; } public static bool WriteFile(string path,string content) { StreamWriter streamWriter = null; try { streamWriter = new StreamWriter(path); streamWriter.Write(content); } catch(Exception ex) { return false; } finally { if (streamWriter != null) streamWriter.Dispose(); } return true; }} ReadFile函数根据传入的地址，读取文件内容，WriteFile则负责保存文件，返回的布尔值用于判断是否保存成功。有人可能会对WriteFile里的catch产生疑惑，在catch里直接return了，那finally的代码不就无法执行了吗？实际上在执行return之前，会先把要return的数据保存，然后执行finally里的语句，最后再return刚刚保存的参数。例如我在catch里return a，而a=1，即使我在finally里把a赋值成2，那最后返回的仍然是1. 查找和替换DFA算法可以极大提高长字符串的查找效率 123456789101112131415161718192021222324252627282930313233343536373839404142public bool textHasChanged = true;public bool wordHasChanged = true;private char[] word;private char[] text;private bool GetWord(){ if(main.richTextBox1.Text.Length == 0) { MessageBox.Show(\"文本内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if(textBox1.Text.Length == 0) { MessageBox.Show(\"查找内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if (textHasChanged) { if (checkBox1.Checked)//不区分大小写 { text = main.richTextBox1.Text.ToLower().ToCharArray(); } else { text = main.richTextBox1.Text.ToCharArray(); } textHasChanged = false; } if (wordHasChanged) { if (checkBox1.Checked)//不区分大小写 { word = textBox1.Text.ToLower().ToCharArray(); } else { word = textBox1.Text.ToCharArray(); } wordHasChanged = false; } return true;} 首先定义char数组word和text，分别表示需要查找的内容和全部文本，使用ToCharArray()将string转化成char数组，在实际使用中，常常会连续使用多次查找功能，如果每次查找时都要转换以下，会增大系统开销，因此需要设定布尔变量来表示字符串内容是否被修改，仅当用户手动修改了word或者text内容时才重新转换。其中“查找”按钮就是简单的统计字符串在文本中出现了多少次，并选中第一次出现的位置，实现较为容易，不展示源码。“上一处”和“下一处”则要根据鼠标光标的位置寻找上一个或下一个出现的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243private void button2_Click(object sender, EventArgs e)//向下查找{ if (!GetWord()) return; int i, j; bool flag; if (checkBox1.Checked) { flag = main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower()); } else { flag = main.richTextBox1.SelectedText.Equals(textBox1.Text); } if (flag) { i = main.richTextBox1.SelectionStart + main.richTextBox1.SelectionLength; } else { i = main.richTextBox1.SelectionStart; } if (i == text.Length) i = 0; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &lt; text.Length &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i + j &lt; text.Length &amp;&amp; text[i + j] == word[j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i, j); main.Focus(); return; } } i += j + 1; alreadySearchLength += j + 1; if (i &gt;= text.Length &amp;&amp; checkBox2.Checked) i = 0; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None);} 查找之前使用Getword()来获取最新的char数组，此时还要考虑一种情况，假设用户需要查找”abc”，并且用户当前已经选中”abc”，就需要将起始位置设置为光标位置的后3格。同时如果用户勾选了”循环”，则变量 i 超出文本长度时，需要将它设置为0，但是这又会引起另一个问题：死循环。为了防止出现死循环，可以设置一个变量alreadySearchLength，这个变量记录已经查找过的字符串长度，当这个变量超过文本长度时，说明已经遍历了全部字符，则退出循环。查找采用了DFA算法，将需要查找的字符串的首字符跟text数组比较，遇到相同的再比较下一个，这样可以减少查找所用时间。向下查找和向上查找代码大致相同，但是向上查找不需要判断当前选中字符串是否就是需要查找的字符串。 123456789101112131415161718192021222324252627private void button3_Click(object sender, EventArgs e)//向上查找{ if (!GetWord()) return; int i = main.richTextBox1.SelectionStart,j; if (i == 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; if (i == text.Length) i = text.Length - 1; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &gt;= 0 &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i - j &gt;= 0 &amp;&amp; text[i - j] == word[word.Length - 1 - j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i - j + 1, j); main.Focus(); return; } } i -= j + 1; alreadySearchLength += j + 1; if (i &lt;= 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void button1_Click(object sender, EventArgs e)//替换{ if (checkBox1.Checked) { if (main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower())) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if(start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if(start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } } else { if (main.richTextBox1.SelectedText.Equals(textBox1.Text)) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if (start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if (start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } }} 替换比起查找较为复杂，首先是判断当前选中字符串是否就是要替换的内容，如果是，替换当前选中的文本，并选中下一个出现的位置；如果不是，直接选中下一个出现的位置。替换是利用字符串截取功能实现的，因此在替换前需要先保存光标位置，替换后再重设光标位置。 对齐与高亮对齐可以使用C#自带的XmlTextWriter来实现，注意命名空间为System.Xml高亮比之前的查找和替换简单，只需要根据尖括号来查找就行，并将尖括号里的内容设置为蓝色 1234567891011121314151617181920212223242526if (richTextBox1.Text.Trim().Equals(\"\")){ MessageBox.Show(\"内容为空.\", \"对齐\"); return;}try{ XmlDocument document = new XmlDocument(); document.LoadXml(richTextBox1.Text); MemoryStream memoryStream = new MemoryStream(); XmlTextWriter writer = new XmlTextWriter(memoryStream, null) { Formatting = Formatting.Indented }; document.Save(writer); StreamReader streamReader = new StreamReader(memoryStream); memoryStream.Position = 0; string xmlString = streamReader.ReadToEnd(); streamReader.Close(); memoryStream.Close(); richTextBox1.Text = xmlString;}catch(Exception ex){ MessageBox.Show(ex.Message);} 启动参数为了实现快捷打开文本文件，需要程序读取启动参数并在启动后立即打开参数指定的文件 12345678910111213141516171819202122232425262728293031public Form1(string[] args){ InitializeComponent(); if(args.Length != 0) { filePath = args[0]; if (!filePath.EndsWith(\".txt\")) { switch(MessageBox.Show(\"XML Reader仅支持文本文件，是否以文本形式打开\" + filePath + \"?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None)) { case DialogResult.OK: break; case DialogResult.No: filePath = null; return; case DialogResult.Cancel: System.Environment.Exit(0); break; } } string content = FileIO.ReadFile(filePath); if (content == null) { filePath = null; } else { LoadXML(content); } }} 注意string[] args并不是自动生成的，而是我手动加上去的，首先在程序入口点Program.Main里获取args，然后再传递给主窗体 12345678910111213static class Program{ /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main(string[] args) { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1(args)); }} 拖拽事件当用户手动拖入某个文件时，快捷打开该文件事件窗口里并没有为我们提供拖拽事件，因此我们需要自己手动定义一个 12richTextBox1.AllowDrop = true;richTextBox1.DragDrop += new DragEventHandler(richTextBox1_DragDrop); 改写DragDrop函数 12345678910111213141516171819202122232425262728293031323334353637private void richTextBox1_DragDrop(object sender, DragEventArgs e){ string[] files = (string[])e.Data.GetData(DataFormats.FileDrop); if (files.Length == 0) return; string file = files[0]; if (Path.GetExtension(file).Equals(\".txt\")) { string s = FileIO.ReadFile(file); if(s == null) { MessageBox.Show(\"读取失败.\", \"XML Reader\", MessageBoxButtons.OK, MessageBoxIcon.Information); return; } else { if (!isSaved) { DialogResult result = MessageBox.Show(\"你想将更改保存到\" + Text + \"吗?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None); switch (result) { case DialogResult.OK: 保存ToolStripMenuItem_Click(null, null); break; case DialogResult.No: break; case DialogResult.Cancel: return; } } LoadXML(s); } } else { MessageBox.Show(\"该类型的文件不被支持.\", \"XML Reader\"); }} 最终成果 源文件EXE程序:https://dearx.lanzoui.com/ioNRKrez29c源文件:https://dearx.lanzoui.com/i7bWzrez2fi","categories":[{"name":"EXE文件","slug":"EXE文件","permalink":"http://example.com/categories/EXE%E6%96%87%E4%BB%B6/"},{"name":"启动参数","slug":"EXE文件/启动参数","permalink":"http://example.com/categories/EXE%E6%96%87%E4%BB%B6/%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"利用RSA加密实现的简易离线验证功能(C#,含代码)","slug":"利用RSA加密实现的简易离线验证功能","date":"2021-07-13T14:02:00.000Z","updated":"2021-08-20T03:10:42.294Z","comments":true,"path":"2021/07/13/利用RSA加密实现的简易离线验证功能/","link":"","permalink":"http://example.com/2021/07/13/%E5%88%A9%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"许多软件都有正版验证功能，它们通常需要联网验证，验证的本质则是加密与解密，本文将使用RSA加密算法实现简易的离线验证功能 RSA加密设p,q是两个超级大的素数，N=pq，数据通过欧拉函数φ(N)来加密，而欧拉函数φ(N)满足φ(N)= φ(pq)=(p-1)(q-1)，如果要算出φ(N)，就必须知道p和q。并且这有一点好处，某人可以公开宣布他的密钥e以及N，任何人都可以给他发送密文，但是只有他能看懂。因为想要破解密码，就必须知道那两个超级大素数p,q.p和q的位数决定了密文的安全性。 硬件绑定由于是离线验证，所以我们能很容易想到可以根据电脑的硬件信息生成一串加密字符串，程序根据加密字符串解密出硬件信息，如果解密出来的信息与实际电脑配置信息相同，则认为验证通过。同时我们还可以在字符串上添加一些额外信息，例如有效期，这样就能做到限定时间的功能。这里以BIOS为例，使用ManagementClass和ManagementObjectCollection读取硬件信息，注意这两个类的命名空间为System.Management 123456789101112131415161718192021ManagementClass mc = null;ManagementObjectCollection moc = null;try{ mc = new ManagementClass(\"Win32_BIOS\"); moc = mc.GetInstances(); foreach (ManagementObject mo in moc) { bios = mo.Properties[\"SerialNumber\"].Value.ToString(); break; }}catch(Exception ex){ bios = null;}finally{ if (mc != null) mc.Dispose(); if (moc != null) moc.Dispose();} 程序读取了BIOS编号，并保存在bios字符串中现在根据BIOS编号生成密文，C#提供了RSACryptoServiceProvider来帮助加密，注意这个类的命名空间为System.Security.Cryptography 12345678910111213141516171819public static string Encrypt(string content){ string publickey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(publickey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false); return Convert.ToBase64String(cipherbytes);} public static string Decrypt(string content){ string privatekey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/hf2dnK7rNfl3lbqghWcpFdu778hUpIEBixCDL5WiBtpkZdpSw90aERmHJYaW2RGvGRi6zSftLh00KHsPcNUMw==&lt;/P&gt;&lt;Q&gt;6Cn/jOLrPapDTEp1Fkq+uz++1Do0eeX7HYqi9rY29CqShzCeI7LEYOoSwYuAJ3xA/DuCdQENPSoJ9KFbO4Wsow==&lt;/Q&gt;&lt;DP&gt;ga1rHIJro8e/yhxjrKYo/nqc5ICQGhrpMNlPkD9n3CjZVPOISkWF7FzUHEzDANeJfkZhcZa21z24aG3rKo5Qnw==&lt;/DP&gt;&lt;DQ&gt;MNGsCB8rYlMsRZ2ek2pyQwO7h/sZT8y5ilO9wu08Dwnot/7UMiOEQfDWstY3w5XQQHnvC9WFyCfP4h4QBissyw==&lt;/DQ&gt;&lt;InverseQ&gt;EG02S7SADhH1EVT9DD0Z62Y0uY7gIYvxX/uq+IzKSCwB8M2G7Qv9xgZQaQlLpCaeKbux3Y59hHM+KpamGL19Kg==&lt;/InverseQ&gt;&lt;D&gt;vmaYHEbPAgOJvaEXQl+t8DQKFT1fudEysTy31LTyXjGu6XiltXXHUuZaa2IPyHgBz0Nd7znwsW/S44iql0Fen1kzKioEL3svANui63O3o5xdDeExVM6zOf1wUUh/oldovPweChyoAdMtUzgvCbJk1sYDJf++Nr0FeNW1RB1XG30=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privatekey); cipherbytes = rsa.Decrypt(Convert.FromBase64String(content), false); return Encoding.UTF8.GetString(cipherbytes);} 两部分核心代码已经完成，在程序中先获取BIOS编号，然后提示用户输入许可证，这个许可证实际上就是密文，程序解密密文，这里需要注意的是，如果用户输入的密文格式有误，则解密函数会抛出异常，因此需要套上try来执行，如果发生异常，则一律认为验证失败。以下是程序界面 文件读写验证模块已经完成，但是每次打开都要用户手动输入许可证，及其繁琐，因此我们需要将许可证保存在本地。首先在D盘创建ducuments目录，在document里创建LICENSE文件，注意需引入命名空间System.IO定义地址 123private static string dirname = @\"D:\\documents\";private static string filename = \"LICENSE.dx\";private static string path = System.IO.Path.Combine(dirname, filename); 创建目录和文件，这里需注意Create后必须dispose，否则接下来读取时会提示被占用 123456System.IO.Directory.CreateDirectory(dirname);if (!File.Exists(path)){ FileStream fileStream = System.IO.File.Create(path); fileStream.Dispose();} 读取和写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static string ReadFile(){ string key = \"\"; string line; StreamReader sr = null; try { sr = new StreamReader(path); while ((line = sr.ReadLine()) != null) { key += line; } } catch(Exception ex) { key = null; } finally { if(sr != null) { sr.Dispose(); } } return key;} public static void WriteFile(string key){ StreamWriter sw = null; try { sw = new StreamWriter(path); sw.Write(key); } catch (Exception ex) { } finally { if (sw != null) { sw.Dispose(); } }} StreamReader和StreamWriter可以放在using里面执行，这样就会自动销毁，但是为了显示dispose的重要性，本程序中手动disposeStreamReader将许可证以文本形式写入文件里，而读取也是文本形式读取，所以文件的后缀名可以随便取。","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"加密算法","slug":"算法/加密算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"RSA","slug":"算法/加密算法/RSA","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/RSA/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"DFA算法-简易Java敏感词过滤(含源文件和上万敏感词列表)","slug":"DFA算法-简易Java敏感词过滤","date":"2021-07-11T14:39:00.000Z","updated":"2021-08-20T03:10:26.610Z","comments":true,"path":"2021/07/11/DFA算法-简易Java敏感词过滤/","link":"","permalink":"http://example.com/2021/07/11/DFA%E7%AE%97%E6%B3%95-%E7%AE%80%E6%98%93Java%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/","excerpt":"","text":"敏感词过滤说白了就是简单的字符串替换，Java本身已经提供了相关函数，但是一旦遇到长文本，或者敏感词数量庞大，效率下降就会非常明显。本文将介绍利用多叉树进行敏感词存储和过滤的方法。 多叉树多叉树是一种特殊的数据结构，如下图Head为头节点，下面的ABCDE均为子树。那么多叉树是如何存储敏感词的呢？首先将敏感词分解为一个一个的字符，例如敏感词”CSDN”，第一个字符是C，则在Head下创建子树”C”(如果已经存在则跳过这一步)。第二个字符是S，则在子树”C”下面创建”S”接下来是D，N，创建完N就可以结束了。如此循环，就可以创建出类似上图的多叉树。检测敏感词时，对于字符串中的每一个字符，先查找Head下是否有存在对应子树，例如字符串”ELN”，先读取第一个字符E，并检查Head，发现存在子树”E”；于是读取第二个字符L，并检查子树E的子树，发现存在L；最后读取第三个字符N，发现子树N还是存在。此时发现子树N后面没有内容，这说明ELN是一个敏感词，于是将ELN替换成”***“。这种算法会出现一个小意外，如果一个敏感词恰好是另一个敏感词的前缀，就会导致较短的敏感词被长的敏感词覆盖，这种情况可以通过添加结束标记来区分。不过我的想法是，如果出现这种情况，直接把前缀屏蔽掉就行了，这样后半段也不算敏感词了(好像实际工作中不能这样做)，因此我没有添加结束标记。 代码首先要先写一个数据结构来模拟多叉树，下图里Word就是一颗树，里面保存着当前字符c和子树next，compareTo是用来排序的，以提高查找效率。 12345678910111213public class Word implements Comparable&lt;Word&gt;{ public char c; public List next = null; public Word(char c){ this.c = c; } @Override public int compareTo(Word word) { return c - word.c; }} 上图的List继承了ArrayList，主要是因为ArrayList可以动态添加元素，便于偷懒 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList; public class List extends ArrayList&lt;Word&gt; { public Word get(char c){ for(Word w :this){ if(w.c == c) return w; } return null; } /** * 二分查找，必须先升序排序 * @param c 需要查找的字符 * @return Word对象：如果找到 null:如果没找到 */ public Word binaryGet(char c){ int left,right,key; Word word; left = 0;right = this.size()-1; while (left &lt;= right){ key = (left + right) / 2; word = get(key); if(word.c == c){ return word; }else if(word.c &gt; c){ right = key - 1; }else { left = key + 1; } } return null; } public Word add(char c){ Word word = new Word(c); super.add(word); return word; }} 以下是核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import java.io.*;import java.util.ArrayList;import java.util.Collections; public final class SensitiveWordFilter { public static List wordList; private final static char replace = '*'; // 替代字符 private final static char[] skip = new char[]{ // 遇到这些字符就会跳过，例如,如果\"AB\"是敏感词，那么\"A B\",\"A=B\"也会被屏蔽 '!','*','-','+','_','=',',','.','@' }; /** * 敏感词替换 * @param text 待替换文本 * @return 替换后的文本 */ public static String Filter(String text){ if(wordList == null || wordList.size() == 0) return text; char[] __char__ = text.toCharArray(); // 把String转化成char数组，便于遍历 int i,j; Word word; boolean flag; // 是否需要替换 for(i=0;i&lt;__char__.length;i++){ // 遍历所有字符 char c = __char__[i]; word = wordList.binaryGet(c); // 使用二分查找来寻找字符，提高效率 if(word != null){ // word != null说明找到了 flag = false; j = i+1; while (j &lt; __char__.length){ // 开始逐个比较后面的字符 if(skip(__char__[j])) { // 跳过空格之类的无关字符 j++; continue; } if(word.next != null){ // 字符串尚未结束，不确定是否存在敏感词 /* 以下代码并没有使用二分查找，因为以同一个字符开头的敏感词较少 例如，wordList中记录了所有敏感词的开头第一个字，它的数量通常会有上千个 假如现在锁定了字符“T”开头的敏感词，而“T”开头的敏感词只有10个，这时使用二分查找的效率反而低于顺序查找 */ word = word.next.get(__char__[j]); if(word == null){ break; } j++; }else { // 字符串已结束，存在敏感词汇 flag = true; break; } } if(word != null &amp;&amp; word.next == null){ flag = true; } if(flag){ // 如果flag==true，说明检测出敏感粗，需要替换 while (i&lt;j){ if(skip(__char__[i])){ // 跳过空格之类的无关字符，如果要把空格也替换成'*'，则删除这个if语句 i++; continue; } __char__[i] = replace; i++; } i--; } } } return new String(__char__); } /** * 加载敏感词列表 * @param words 敏感词数组 */ public static void loadWord(ArrayList&lt;String&gt; words){ if(words == null) return; char[] chars; List now; Word word; wordList = new List(); for(String __word__:words){ if(__word__ == null) continue; chars = __word__.toCharArray(); now = wordList; word = null; for(char c:chars){ if(word != null) { if(word.next == null) word.next = new List(); now = word.next; } word = now.get(c); if(word == null) word = now.add(c); } } sort(wordList); } /** * 加载敏感词txt文件，每个敏感词独占一行，不可出现空格，空行，逗号等非文字内容,必须使用UTF-8编码 * @param path txt文件的绝对地址 */ public static void loadWordFromFile(String path){ String encoding = \"UTF-8\"; File file = new File(path); try{ if(file.isFile() &amp;&amp; file.exists()){ InputStreamReader inputStreamReader = new InputStreamReader( new FileInputStream(file),encoding ); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((line = bufferedReader.readLine()) != null){ list.add(line); } bufferedReader.close(); inputStreamReader.close(); loadWord(list); } } catch (IOException e) { e.printStackTrace(); } } /** * 对敏感词多叉树递增排序 * @param list 待排序List */ private static void sort(List list){ if(list == null) return; Collections.sort(list); // 递增排序 for(Word word:list){ sort(word.next); } } /** * 判断是否跳过当前字符 * @param c 待检测字符 * @return true:需要跳过 false:不需要跳过 */ private static boolean skip(char c){ for(char c1:skip){ if(c1 == c) return true; } return false; }} 测试 12345678910111213141516171819public class Main { public static void main(String[] args) throws Exception{ SensitiveWordFilter.loadWordFromFile(\"D:/SensitiveWordList.txt\"); StringBuilder stringBuilder = new StringBuilder(); long t1,t2; for(int i=0;i&lt;100;i++){ stringBuilder.append(\"123TM,D123\"); } String s = stringBuilder.toString(); String result = null; t1 = System.nanoTime(); for(int i=0;i&lt;10000;i++){ result = SensitiveWordFilter.Filter(s); } t2 = System.nanoTime(); System.out.println(result); System.out.println((t2 - t1) / 1000000 + \"毫秒\"); }} 测试使用的敏感词库总共包含14596个敏感词(可能有个别重复),在测试代码里生成了一个长度为1000的字符串，总共包含100个相同敏感词，敏感词中间有逗号隔开重复执行过滤10000次，并打印结果和时间，结果如下 可以看到程序成功地过滤了敏感词，并保留了逗号，总耗时335毫秒，平均每次过滤仅需要0.03毫秒，并且是在上万个敏感词和超长字符串的情况下。 源文件+敏感词列表 在寻找敏感词列表时发现很多人的分享都被取消了，为了防止敏感词列表被检测出敏感词，使用了zip格式并加密。敏感词库存在部分重复，不过不影响使用。 密码:dearxuan 密码:dearxuan 密码:dearxuan 源代码+敏感词列表:https://dearx.lanzoui.com/iIh95ralmrc单独敏感词列表:https://dearx.lanzoui.com/iFQSrralmsd","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"敏感词过滤","slug":"算法/敏感词过滤","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"多叉树","slug":"算法/敏感词过滤/多叉树","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/"},{"name":"DFA算法","slug":"算法/敏感词过滤/多叉树/DFA算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/DFA%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"DearXuan"},{"title":"高斯模糊的Java实现及优化","slug":"高斯模糊的Java实现及优化","date":"2021-07-05T05:45:00.000Z","updated":"2021-08-20T03:10:15.772Z","comments":true,"path":"2021/07/05/高斯模糊的Java实现及优化/","link":"","permalink":"http://example.com/2021/07/05/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E7%9A%84Java%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"","text":"高斯模糊是被广泛使用的图形算法之一，在实现高斯模糊之前，先要了解正态分布 正态分布一维的正态分布为直接让f(x)和f(y)相乘，就得到了二维的正态分布此处直接令μ=0，将会在下面解释。 权值矩阵设有一个(2n+1)阶矩阵M，且有，我们称这个矩阵为权值矩阵，称为(i,j)点处的权。其中n是高斯模糊的半径。 离散卷积离散卷积是卷积对离散量的特殊形式，假设现有原图矩阵A,权值矩阵B,则点(x,y)处的离散卷积为在更严格的定义中，A(i,j)应该与B(u-i,v-j)相乘，但是针对本文的高斯模糊而言，其效果是一样的，且上面给出的公式更为简洁。 现在举个例子，有一张尺寸为3*3的图片S，将其颜色转化成矩阵A，为有权值矩阵B为将A(i,j)与B(i,j)相乘，将结果相加(-1) x 2 + (-1) x 4 + (-1) x 6 + (-1) x 8 + 5 x 5 = 5则以上两个矩阵的离散卷积结果为5，这就是矩阵A经过处理后得到的新矩阵M(2,2)的值。 在高斯模糊中，设模糊半径为n，则定义一个维数为2n+1的权值矩阵G，且G(i,j)=f(i-n-1,j-n-1)，类似于将一个直角坐标系放在了G的中点处，这就是μ=0的原因。此处的f是二维正态分布函数。然后求和，将矩阵的每个数除以这个和。求和的步骤是防止图片过亮或过暗。将得到的矩阵G代替B计算，其结果就是高斯模糊的结果 优化上述方法的效率较低，在介绍正态分布时，二维的正态分布函数是两个一维函数相乘得到的，这两个一维函数分别是f(x)和f(y)，f(x)代表水平方向，f(y)代表垂直方向。对于一个n维权值矩阵，用它来处理a*b尺寸的图片，如果用二维正态分布函数来计算，总共需要计算a*b*n*n=abn²次，及其繁琐。这时我们可以使用一维的正态分布函数，得出一个“权值列向量”，这个向量的作用类似权值矩阵，用这个列向量把图片横向处理，相当于f(x)，再用它把图片纵向处理，相当于f(y)，此时图片经过两次处理，相当于f(x)*f(y)，也可以达到二维正态分布的效果，而计算量仅仅是a*b*n+a*b*n=2abn，下降了一个数量级。该方法不详细介绍，将在代码中展示。 代码实现GaussianBlur类，算法的核心部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public final class GaussianBlur { private static final int precision = 10000; // 精度，由于返回的是int数组，精度较低，因此需要将所有值同时扩大数倍，可以理解为把小数点向右移动 private static final double E = 2.718281828459045;//自然常数e private static final double PI = 3.141592653589793;//圆周率 /** * 快速高斯模糊 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] GaussianBlur(int[][][] picture,int radius){ int i, j, x, R, G, B, proportion, subscript; int[] matrix = LinearNormalDistribution(radius,1.5); int width = picture[0].length, height = picture[0][0].length; int[][][] color_1 = new int[3][width][height]; // 用来存高斯模糊后的数据 int[][][] color_2 = new int[3][width][height]; // 临时存储纵向滤波之后的数据 //纵向滤波 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; height) ? x : 2 * j - x; // 如果坐标越界了，则计算对称点来代替 R += picture[0][i][subscript] * proportion; G += picture[1][i][subscript] * proportion; B += picture[2][i][subscript] * proportion; } color_2[0][i][j] = R / precision; color_2[1][i][j] = G / precision; color_2[2][i][j] = B / precision; } } //横向滤波 for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * j - x; R += color_2[0][subscript][i] * proportion; G += color_2[1][subscript][i] * proportion; B += color_2[2][subscript][i] * proportion; } //注意for语句中i代表高度，j代表宽度，所以下面三个语句的i和j并没有写错位置 color_1[0][j][i] = R / precision; color_1[1][j][i] = G / precision; color_1[2][j][i] = B / precision; } } return color_1; } /** * 慢速高斯模糊，采用二维正态分布的方法来处理图像 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] SlowGaussianBlur(int[][][] picture,int radius){ //flag为真时计算加权，为假时直接代入矩阵 int[][] matrix = NormalDistribution(radius,1.5); int i, j, x, y, R, G, B, proportion, left, right, width = picture[0].length, height = picture[0][0].length; int[][][] color = new int[3][width][height]; //选取每个点 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { //选取半径为radius的矩阵 R = G = B = 0; for (x = i - radius; x &lt;= i + radius; x++) { for (y = j - radius; y &lt;= j + radius; y++) { //求出颜色 proportion = matrix[x + radius - i][y + radius - j]; left = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * i - x; right = (y &gt;= 0 &amp;&amp; y &lt; height) ? y : 2 * j - y; R += picture[0][left][right] * proportion; G += picture[1][left][right] * proportion; B += picture[2][left][right] * proportion; } } color[0][i][j] = R / precision; color[1][i][j] = G / precision; color[2][i][j] = B / precision; } } return color; } /** * 用一维正态分布函数来计算“权值列向量”，效率较高 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return “权值列向量” */ private static int[] LinearNormalDistribution(int radius,double SIGMA){ int[] matrix = new int[2 * radius + 1]; // 定义一个列向量 int sum, i; //计算各个点的正态分布值 sum = matrix[radius] = (int) (precision / (2 * PI * SIGMA * SIGMA)); // sum的初值为向量中心点的值，例如向量(1,2,3,2,1)，则初值为3 for (i = 1; i &lt;= radius; i++) { //根据对称性，可以减少一倍的运算量，i=0的情况已经在sum初值那一步考虑 matrix[radius-i] = matrix[radius+i] = (int) ((Math.pow(E, -i * i / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA)) * precision); sum += matrix[radius+i] * 2; // 计算向量所有值之和 } for (i = 0; i &lt; 2 * radius + 1; i++) { matrix[i] = matrix[i] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } return matrix; } /** * 用二维正态分布函数来计算权值矩阵，效率较低 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return 权值矩阵 */ private static int[][] NormalDistribution(int radius, double SIGMA) { int sum = 0, i, j; int[][] matrix = new int[2 * radius + 1][2 * radius + 1]; // 定义一个矩阵 //计算各个点的正态分布值 for (i = 0; i &lt;= radius; i++) { for (j = 0; j &lt;= radius; j++) { //写入矩阵并累加，根据矩阵的对称性可以减少3/4的运算量 matrix[radius-i][radius-j] = matrix[radius-i][radius+j] = matrix[radius+i][radius-j] = matrix[radius+i][radius+j] = (int) (Math.pow(E, -(i * i + j * j) / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA) * precision); sum += 4 * matrix[radius+i][radius+j]; } } //计算权值 for (i = 0; i &lt;= 2 * radius; i++) { for (j = 0; j &lt;= 2 * radius; j++) { matrix[i][j] = matrix[i][j] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } } return matrix; }} Filter类，通过调用GaussianBlur类来处理图像 1234567891011121314151617181920212223242526272829303132333435import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException; public final class Filter { public static BufferedImage GaussianBlur(String path){ int pixel; try { BufferedImage image = ImageIO.read(new File(path)); int width = image.getWidth(),height = image.getHeight(); int[][][] picture = new int[3][width][height]; for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = image.getRGB(i,j); //获取每个点的RGB值 picture[0][i][j] = (pixel &amp; 0xff0000) &gt;&gt; 16; picture[1][i][j] = (pixel &amp; 0xff00) &gt;&gt; 8; picture[2][i][j] = (pixel &amp; 0xff); } } picture = GaussianBlur.GaussianBlur(picture,100); // 快速高斯模糊 for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = ((picture[0][i][j] &amp; 0xff) &lt;&lt; 16) + ((picture[1][i][j] &amp; 0xff) &lt;&lt; 8) + (picture[2][i][j] &amp; 0xff); image.setRGB(i,j,pixel); } } return image; } catch (IOException e) { e.printStackTrace(); return null; } }} Main,打开1.jpg并高斯模糊，保存为2.jpg 1234567891011import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File; public class Main { public static void main(String[] args) throws Exception{ BufferedImage image = Filter.GaussianBlur(\"D://1.jpg\"); ImageIO.write(image,\"jpg\",new File(\"D://2.jpg\")); }} 效果原图 高斯模糊之后的图(半径20，SIGMA1.5)源文件https://dearx.lanzoui.com/iSxBJr0uu6d","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"图像算法","slug":"算法/图像算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"DearXuan"}],"categories":[{"name":"底层","slug":"底层","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82/"},{"name":"内存","slug":"底层/内存","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82/%E5%86%85%E5%AD%98/"},{"name":"底层原理","slug":"底层原理","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"二进制","slug":"底层原理/二进制","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"EXE文件","slug":"EXE文件","permalink":"http://example.com/categories/EXE%E6%96%87%E4%BB%B6/"},{"name":"启动参数","slug":"EXE文件/启动参数","permalink":"http://example.com/categories/EXE%E6%96%87%E4%BB%B6/%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"加密算法","slug":"算法/加密算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"RSA","slug":"算法/加密算法/RSA","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/RSA/"},{"name":"敏感词过滤","slug":"算法/敏感词过滤","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"多叉树","slug":"算法/敏感词过滤/多叉树","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/"},{"name":"DFA算法","slug":"算法/敏感词过滤/多叉树/DFA算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/DFA%E7%AE%97%E6%B3%95/"},{"name":"图像算法","slug":"算法/图像算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}