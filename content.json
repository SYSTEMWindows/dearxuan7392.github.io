{"meta":{"title":"DearXuan的主页","subtitle":"","description":"欢迎访问DearXuan的主页!","author":"DearXuan","url":"http://example.com","root":"/"},"pages":[{"title":"DearXuan","date":"2021-08-20T06:34:06.930Z","updated":"2021-08-20T06:34:06.930Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我的CSDN主页:https://blog.csdn.net/qq_39200794"},{"title":"所有标签","date":"2021-08-20T07:13:17.464Z","updated":"2021-08-20T07:13:17.464Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-08-20T07:10:59.625Z","updated":"2021-08-20T07:10:59.625Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"平方根倒数快速算法","slug":"平方根倒数快速算法","date":"2021-08-18T10:20:00.000Z","updated":"2021-08-20T08:40:15.644Z","comments":true,"path":"2021/08/18/平方根倒数快速算法/","link":"","permalink":"http://example.com/2021/08/18/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95/","excerpt":"","text":"单位向量时需要用到平方根倒数，而计算单位向量在游戏引擎中会大量使用，属于底层代码，因此其效率将会直接影响游戏体验。 雷神之锤3中使用了以下代码 float Q_rsqrt(float number) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = *(long *) &amp;y; i = 0x5F3759DF - (i &gt;&gt; 1); y = *(float *) &amp;i; y = y * (threehalfs - (x2 * y * y)); return y; } 本文将分析上述代码的含义 float内存结构float类型总共占用32位，其内存结构采用科学计数法表示。第一位表示符号，接下来8位表示指数，后23位表示尾数 以4.25为例，其内存中的结构为0 10000001 00010000000000000000000第一位0表示这个数是正数. 接下来的8位表示指数，其指在0-255之间，但是这样就无法表示负指数了，因此规定正指数第一位是1，负指数第一位是0，将这8位转换成10进制后减去127就是实际的指数。这里的10000001转换成10进制后是129，因此表示2^2 = 4. 接下来的23位表示尾数。前面提到float在内存中是以科学计数法形式表示，在十进制中，科学计数法的个位数一定在1-9之间，因此在二进制中，科学计数法的个位数一定是1，既然一定是1，那就没有必要保存了，因此尾数0001实际上是1.0001，转换成十进制就是1.0625. 所以最终十进制数字就是1.0625 * 2^2 = 4.25. 等价无穷小方法我们令8位指数转换成为十进制后为E，23位尾数转换成十进制后为W. 则原float数字可以表示为取2为底的对数，得在上面的分析中，我们知道M/2^23一定小于1，此时对数公式满足log(1+x)等价无穷小模型. 我们用x+μ来近似代替2为底的对数。现在上述表达式可以写成提出1/2^23，得 位操作float无法进行位操作，而long可以，并且都是4字节，因此可以把float*转换成long*来进行位操作. float y = number; long i = *(long *) &amp;y; 计算y的平方根倒数，就是计算y的-0.5次方，直接计算的效率低下，但是我们已经发现可以用log的方法来加速计算.将y用上面的表达式替换 设取对数带入上面的表达式化简可以看到右边的式子是一个常数减去一个变量的一半，这个变量就是代码中的number. 如何求μ的值？观察函数图像我们希望y=x+μ尽可能均分红色和黄色曲线，因此我们可以作红色曲线的切线，求出它和y轴的交点.代进原方程，得到y≈0.528766，x≈0.442695 相减，得到μ=(y-x) / 2 = 0.0430355 将这个μ的值代入表达式，计算结果转换为十六进制，就是0x5F3759DF i = 0x5F3759DF - (i &gt;&gt; 1); 由于float无法进行位运算，所以将它转换成long后再位移，虽然这样会损失精度，但是影响可以忽略不计. 此时已经运算完成，再把long转换回float y = *(float *) &amp;i; 牛顿迭代法当前得到的y仍然是一个近似值. 设y是x的平方根倒数，则函数表达式为转换为x关于y的函数，得到利用牛顿迭代法带入Xn=y，得到化简得到最后一行代码. y = y * (threehalfs - (x2 * y * y));","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"DearXuan"},{"title":"C#的GPU加速方法","slug":"C-的GPU加速方法","date":"2021-08-13T06:11:00.000Z","updated":"2021-08-20T07:43:46.602Z","comments":true,"path":"2021/08/13/C-的GPU加速方法/","link":"","permalink":"http://example.com/2021/08/13/C-%E7%9A%84GPU%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/","excerpt":"","text":"本文将通过C#调用dll的方法来实现并发计算 在VS2019里新建动态链接库项目，在pch.h里定义函数 // pch.h: 这是预编译标头文件。 // 下方列出的文件仅编译一次，提高了将来生成的生成性能。 // 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。 // 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。 // 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。 #ifndef PCH_H #define PCH_H // 添加要在此处预编译的标头 #include \"framework.h\" extern \"C\" _declspec(dllexport) void Sum(int* s,int a[],int b[],int length); #endif //PCH_H 在pch.cpp里实现该函数 // pch.cpp: 与预编译标头对应的源文件 #include \"pch.h\" #include &lt;amp.h&gt; // 当使用预编译的头时，需要使用此源文件，编译才能成功。 using namespace Concurrency; extern \"C\" _declspec(dllexport) void Sum(int* s, int a[], int b[],int length) { array_view&lt;const int, 1&gt; aArray(length, a); array_view&lt;const int, 1&gt; bArray(length, b); array_view&lt;int, 1&gt; sum(length, s); parallel_for_each( sum.extent, [=](index&lt;1&gt; idx) restrict(amp) { sum[idx] = aArray[idx] + bArray[idx]; } ); } 该函数接收4个参数，分别用来储存结果，a数组，b数组，数组长度，并将a和b数组相加，结果储存在s里面。 array_view表示包含在一个容器中的数据的N维视图，各项参数的含义如下 const int：类型， 1：维数 aArray：array_view的实例 length：长度 a：数据源 如果是二维数组，则要改成下面的形式 array_view&lt;const int, 2&gt; aArray(width,height, a); parallel_for_each语句能够进行并发计算,index&lt;1&gt;指idx是一维的，如果是二维数组，需要改成index&lt;2&gt;，此时idx相当于(i,j)，通过idx[0]和idx[1]获得行号和列号 例如 int row = idx[0]; int col = idx[1]; aArray[idx]和aArray(row,col)是等效的 将上述代码生成dll，并放在C#程序的目录下 导入刚刚写的dll [DllImport(\"Dll1.dll\", EntryPoint = \"Sum\", CallingConvention = CallingConvention.Cdecl)] public static extern void Sum(IntPtr s,int[] a, int[] b,int length); 生成随机数数组，求和 static void Main(string[] args) { const int size = 100; int[] s = new int[size]; int[] a = new int[size]; int[] b = new int[size]; Random random = new Random(); for(int i = 0; i &lt; size; i++) { a[i] = random.Next(0, 100); b[i] = random.Next(100, 200); } unsafe { IntPtr p = Marshal.UnsafeAddrOfPinnedArrayElement(s, 0); Sum(p, a, b, size); } for(int i = 0; i &lt; size; i++) { Console.WriteLine(a[i] + \"+\" + b[i] + \"=\" + s[i]); } Console.ReadLine(); } 使用StopWatch类来计算耗时(命名空间System.Diagnostics) Stopwatch watch1 = new Stopwatch(); watch1.Start(); for(int i = 0; i &lt; size; i++) { s[i] = a[i] + b[i]; } watch1.Stop(); Console.WriteLine(\"CPU耗时:\" + watch1.Elapsed.TotalMilliseconds); Stopwatch watch2 = new Stopwatch(); watch2.Start(); Sum(p, a, b, size); watch2.Stop(); Console.WriteLine(\"GPU耗时:\" + watch2.Elapsed.TotalMilliseconds); 由于加载dll本身需要时间，所以在计时之前需要先调用一次Sum函数。测试代码是计算4亿个数的和，可以看到GPU计算比CPU计算少了300毫秒，但是CPU在循环2亿次的情况下居然仅仅比GPU多了300毫秒，这是因为GPU无法从内存读取数据，需要把数据先复制到显存里才能计算，计算完又需要把数据复制回来，而主要时间开销都在数据的复制里面。 现实情况下，循环体里不可能只有一行代码，假设循环体里有10个语句，那么CPU的执行时间就会翻10倍，而GPU的执行时间也会翻10倍，但是由于主要耗时操作是数据的复制，所以实际增长不会特别明显。 下面我们修改一下代码。 extern \"C\" _declspec(dllexport) void Sum(int* s, int a[], int b[],int length) { array_view&lt;const int, 1&gt; aArray(length, a); array_view&lt;const int, 1&gt; bArray(length, b); array_view&lt;int, 1&gt; sum(length, s); parallel_for_each( sum.extent, [=](index&lt;1&gt; idx) restrict(amp) { sum[idx] = aArray[idx] + bArray[idx]; if (idx[0] % 5 == 0) { sum[idx] += 5; } if (idx[0] % 7 == 0) { sum[idx] += 7; } if (idx[0] % 11 == 0) { sum[idx] += 11; } if (idx[0] % 13 == 0) { sum[idx] += 13; } if (idx[0] % 17 == 0) { sum[idx] += 17; } } ); } watch1.Start(); for(int i = 0; i &lt; size; i++) { s[i] = a[i] + b[i]; if (i % 5 == 0) { s[i] += 5; } if (i % 7 == 0) { s[i] += 7; } if (i % 11 == 0) { s[i] += 11; } if (i % 13 == 0) { s[i] += 13; } if (i % 17 == 0) { s[i] += 17; } } watch1.Stop(); Console.WriteLine(\"CPU耗时:\" + watch1.Elapsed.TotalMilliseconds); 这次改用100万量级的数据 现在GPU的优势就完全体现出来了","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"Dll","slug":"Dll","permalink":"http://example.com/tags/Dll/"},{"name":"GPU编程","slug":"GPU编程","permalink":"http://example.com/tags/GPU%E7%BC%96%E7%A8%8B/"},{"name":"硬件加速","slug":"硬件加速","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"}],"author":"DearXuan"},{"title":"Wallpaper透视效果的C++实现","slug":"Wallpaper透视效果的C-实现","date":"2021-08-07T13:54:00.000Z","updated":"2021-08-20T07:43:53.522Z","comments":true,"path":"2021/08/07/Wallpaper透视效果的C-实现/","link":"","permalink":"http://example.com/2021/08/07/Wallpaper%E9%80%8F%E8%A7%86%E6%95%88%E6%9E%9C%E7%9A%84C-%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Wallpaper的透视图实际上包含了两张图，一张是非透视图，即正常情况下能够被看到的图片，另一张是透视图，即鼠标移到上面才会部分显示的图片。 本文将使用Qt框架实现类似效果 最终效果 代码桌面子窗体将自己的窗体设置成桌面的子窗体，其原理在之前的Wallpaper文章中已经介绍过，故直接放出代码，不再解释。 void SetFather(HWND child){ HWND hwnd = GetBackground(); if(hwnd == NULL){ SendMessage(hwnd,0x052C,0,0); hwnd = GetBackground(); } if(hwnd != NULL){ SetParent(child,hwnd); } } HWND GetBackground(){ HWND hwnd = FindWindowA(\"progman\",\"Program Manager\"); HWND worker = NULL; do{ worker = FindWindowExA(NULL,worker,\"workerW\",NULL); if(worker != NULL){ char buff[200] = {0}; int ret = GetClassNameA(worker,(PCHAR)buff,sizeof(buff)*2); if(ret == 0){ return NULL; } } if(GetParent(worker) == hwnd){ return worker; } }while(worker != NULL); return NULL; } 鼠标事件捕捉由于将窗体设置成了背景层的子窗体，而背景层上面还有一层图标层，所以我们自己写的窗体将无法接受鼠标事件，也就无法对鼠标移动做出反应，因此我们需要使用HOOK拦截系统的鼠标事件，HOOK程序将会在鼠标移动事件发生之前优先执行，这样就可以捕捉到鼠标移动事件。 HHOOK hook; void GetHook(){ hook = SetWindowsHookEx(WH_MOUSE_LL,mouseProc,GetModuleHandle(NULL),NULL); } LRESULT CALLBACK mouseProc(int nCode,WPARAM wParam,LPARAM lParam){ if(nCode == HC_ACTION){ if(wParam == WM_MOUSEMOVE){ main-&gt;repaint();//界面重绘，main是本窗体，相当于this } } return false; } 绘图与蒙版实现透视效果的原理是先绘制非透视图，然后根据鼠标位置绘制透视图的一小部分，为了方便，我们称非透视图为“背景图”，称透视图为“前景图”，因为透视图是覆盖在非透视图上面的。 全局变量 QPixmap *foreground;//前景图,透视图 QPixmap *background;//背景图,非透视图 QPixmap *cut;//透视图裁剪后的图片 QBitmap *maskBitmap;//蒙版 QPixmap *maskPic;//裁剪后的蒙版 QColor *color;//透视颜色 int x1,x2,y1,y2;//透视区域的坐标 int startX,startY;//蒙版起始坐标 int radius;//透视半径 int Desktop_width,Desktop_height;//桌面的尺寸 bool repaintable = true;//重绘 LoadPicture()函数用来加载图片 void Widget::LoadPicture(QString fore,QString back){ foreground = new QPixmap(); background = new QPixmap(); cut = new QPixmap(); foreground-&gt;load(fore); background-&gt;load(back); QDesktopWidget *desktop = QApplication::desktop(); QRect rect = desktop-&gt;screenGeometry(); Desktop_width = rect.width(); Desktop_height = rect.height(); *foreground = foreground-&gt;scaled(rect.width(),rect.height(),Qt::IgnoreAspectRatio,Qt::SmoothTransformation); *background = background-&gt;scaled(rect.width(),rect.height(),Qt::IgnoreAspectRatio,Qt::SmoothTransformation); } 在SetRadius()函数中，需要初始化蒙版，先定义一个长为2*radius的正方形QBitmap，然后画上颜色为color(黑色)的圆形 void Widget::SetRadius(int r){ if(radius == r) return; radius = r; QSize size(2*radius, 2*radius); maskBitmap = new QBitmap(size); maskPic = new QPixmap(size); color = new QColor(0,0,0); QPainter painter(maskBitmap); painter.setRenderHint(QPainter::Antialiasing); painter.setRenderHint(QPainter::SmoothPixmapTransform); painter.fillRect(0, 0, size.width(), size.height(), Qt::white); painter.setBrush(*color); painter.drawRoundedRect(0, 0, size.width(), size.height(), radius, radius); repaint(); } 根据鼠标位置计算出正确的区域大小，这是一个以鼠标为中心，2*radius为长的正方形，(x1,y1)是左上角坐标，(x2,y2)是右下角坐标，这两个坐标构成了一个裁剪框，但是这个坐标有可能会超出屏幕范围，一旦超出，就会导致裁剪的时候出现图片拉伸，所以需要加上判断语句来限制大小。 接着根据限制后的大小和位置，在前景图(透视图)上裁剪出相应区域。 startX和startY是蒙版的起始位置，如果(x1,y1)超出屏幕区域，就意味着裁剪框将不是正方形，而蒙版却是正方形的，所以必须对蒙版也进行裁剪，使蒙版的大小恰好等于裁剪框的大小。 void Widget::paintEvent(QPaintEvent *){ GetCursorPos(&amp;p); x1 = p.x - radius; y1 = p.y - radius; x2 = p.x + radius; y2 = p.y + radius; if(x1 &lt; 0) { startX = -x1; x1 = 0; }else{ startX = 0; } if(y1 &lt; 0) { startY = -y1; y1 = 0; }else{ startY = 0; } if(x2 &gt; Desktop_width) x2 = Desktop_width; if(y2 &gt; Desktop_height) y2 = Desktop_height; *cut = foreground-&gt;copy(x1,y1,x2-x1,y2-y1);//裁剪前景图(透视图) *maskPic = maskBitmap-&gt;copy(startX,startY,x2-x1,y2-y1);//裁剪蒙版 cut-&gt;setMask(maskPic-&gt;createMaskFromColor(*color,Qt::MaskOutColor));//给cut设置蒙版 QPainter painter(this); painter.drawPixmap(0,0,width(),height(),*background);//先画背景图 painter.drawPixmap(x1,y1,x2-x1,y2-y1,*cut);//在画前景图(透视图)，覆盖在背景图上面 } 内存释放HOOK会降低计算机效率，所以在使用完毕后必须释放，当关闭程序时windows系统会自动释放HOOK，但是我们希望用户在主动关闭壁纸但是还未退出程序时也要释放掉HOOK，同时摧毁窗体。 Dispose()函数的用途就是摧毁窗体，然后释放HOOK void Widget::Dispose(){ this-&gt;hide(); UnhookWindowsHookEx(hook); this-&gt;close(); } 任务栏角标之前文章已经介绍过，这里直接放出代码。 void Set::AddTray(){ //QSystemTrayIcon tray; 在.h文件中定义 tray.setToolTip(\"X-Ray\"); tray.setIcon(QIcon(\":Icon/ico.ico\")); QMenu *menu = new QMenu(); QAction *action_showDialog = new QAction(\"打开主窗口\"); QAction *action_free = new QAction(\"释放内存\"); QAction *action_exit = new QAction(\"退出\"); menu-&gt;addAction(action_showDialog); menu-&gt;addAction(action_free); menu-&gt;addSeparator(); menu-&gt;addAction(action_exit); tray.setContextMenu(menu); connect(action_showDialog,SIGNAL(triggered(bool)),this,SLOT(ShowDialog())); connect(action_free,SIGNAL(triggered(bool)),this,SLOT(on_button_free_clicked())); connect(action_exit,SIGNAL(triggered(bool)),this,SLOT(on_button_exit_clicked())); tray.show(); } 源文件https://dearx.lanzoui.com/ixRT2scl3nc","categories":[{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/categories/Wallpaper/"},{"name":"Qt","slug":"Wallpaper/Qt","permalink":"http://example.com/categories/Wallpaper/Qt/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/tags/Wallpaper/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"author":"DearXuan"},{"title":"使用C++实现的仿Wallpaper动态壁纸软件(含源文件)","slug":"使用C-实现的仿Wallpaper动态壁纸软件","date":"2021-07-28T09:46:00.000Z","updated":"2021-08-20T07:43:59.409Z","comments":true,"path":"2021/07/28/使用C-实现的仿Wallpaper动态壁纸软件/","link":"","permalink":"http://example.com/2021/07/28/%E4%BD%BF%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%BFWallpaper%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"在上一篇博客中，已经介绍了wallpaper的实现原理，并用C#实现，本文将使用C++和Qt框架实现，由于之前已经介绍过具体思路，本文将跳过分析过程，直接上代码。 新建Qt项目，系统自动生成widget.h,widget.cpp,main.cpp。 我们将使用widget作为主窗体 窗体设计 在项目pro里加上 QT += multimedia multimediawidgets widget里添加头文件 #include &lt;QVideoWidget&gt; #include &lt;QMediaPlayer&gt; #include &lt;QMediaPlaylist&gt; 创建播放器和播放窗口 QVideoWidget videoWidget; QMediaPlayer player; 在设计界面添加四个按钮，添加槽函数 private slots: void on_openButton_clicked(); void on_playButton_clicked(); void on_pauseButton_clicked(); void on_exitButton_clicked(); 获取背景层窗体句柄 HWND GetBackground(){ HWND background = NULL; HWND hwnd = FindWindowA(\"progman\",\"Program Manager\"); HWND worker = NULL; do{ worker = FindWindowExA(NULL,worker,\"workerW\",NULL); if(worker != NULL){ char buff[200] = {0}; int ret = GetClassNameA(worker,(PCHAR)buff, sizeof(buff) * 2); if(ret == 0) { return NULL; } } if(GetParent(worker) == hwnd){ background = worker; } } while (worker != NULL); return background; } 这里有可能会返回NULL,因为某些系统没有WorkerW窗体，可以在GetBackground()里加上下面这句代码 SendMessage(hwnd,0x052C,0,0); 最终代码 //获取背景窗体句柄 HWND GetBackground() { //背景窗体没有窗体名，但是知道它的类名是workerW，且有父窗体Program Maneger，所以只要 //遍历所有workW类型的窗体，逐一比较它的父窗体是不是Program Manager就可以找到背景窗体 HWND hwnd = FindWindowA(\"progman\", \"Program Manager\"); HWND worker = NULL; do { worker = FindWindowExA(NULL, worker, \"workerW\", NULL); if (worker != NULL) { char buff[200] = {0}; int ret = GetClassNameA(worker, (PCHAR) buff, sizeof(buff) * 2); if (ret == 0) { return NULL; } } if (GetParent(worker) == hwnd) { return worker;//返回结果 } } while (worker != NULL); //没有找到 //发送消息生成一个WorkerW窗体 SendMessage(hwnd,0x052C,0,0); //重复上面步骤 do { worker = FindWindowExA(NULL, worker, \"workerW\", NULL); if (worker != NULL) { char buff[200] = {0}; int ret = GetClassNameA(worker, (PCHAR) buff, sizeof(buff) * 2); if (ret == 0) { return NULL; } } if (GetParent(worker) == hwnd) { return worker;//返回结果 } } while (worker != NULL); return NULL; } 在C#制作动态壁纸软件时，我专门为刷新背景做了一个exe文件，因此这里可以直接调用 void ReFreshBackground(){ WinExec(\"D:\\\\documents\\\\Wallpaper\\\\ReFreshBackground.exe\",0); } 当我们点击“打开”按钮时，如果是第一次打开，需要新建窗体并设置为背景层窗体的子窗体，而之后就不用了，因此设立布尔变量firstPlay来判断是否第一次打开文件 bool firstPlay = true; void Widget::on_openButton_clicked() { QString file = QFileDialog::getOpenFileName( this, \"打开文件\", \"\", \"\"); if(!file.isEmpty()){ if(firstPlay){ HWND hwnd = (HWND) videoWidget.winId(); SetBackground(hwnd); videoWidget.setWindowFlags(Qt::FramelessWindowHint); videoWidget.showFullScreen(); firstPlay = false; } player.setMedia(QMediaContent(QUrl::fromLocalFile(file))); player.setVideoOutput(&amp;videoWidget); player.play(); } } 给别的按钮设置槽函数 void Widget::on_playButton_clicked() { player.play(); } void Widget::on_pauseButton_clicked() { player.pause(); } void Widget::on_exitButton_clicked() { if(!firstPlay){ ReFreshBackground(); } qApp-&gt;exit(0); } 在退出时也需要先判断是否打开了文件，如果没有打开，则不需要刷新壁纸。 将child窗体设置为背景层窗体的子窗体 void SetBackground(HWND child){ SetParent(child,GetBackground()); } 最终效果 内存和GPU占用 源文件:https://dearx.lanzoui.com/iMZJkryfg4b 如果出现0x80040266错误，是因为你没有安装LAVFilters LAVFilters下载地址:https://dearx.lanzoui.com/iz21rryfkja(安装后重启电脑)","categories":[{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/categories/Wallpaper/"},{"name":"Qt","slug":"Wallpaper/Qt","permalink":"http://example.com/categories/Wallpaper/Qt/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/tags/Wallpaper/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"author":"DearXuan"},{"title":"Wallpaper的原理和C#实现","slug":"Wallpaper的原理和C-实现","date":"2021-07-27T04:09:00.000Z","updated":"2021-08-20T07:24:23.768Z","comments":true,"path":"2021/07/27/Wallpaper的原理和C-实现/","link":"","permalink":"http://example.com/2021/07/27/Wallpaper%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8CC-%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"wallpaper是一款优秀的动态壁纸软件，除了播放动画以外，还可以执行程序，甚至可以实时响应鼠标移动。 windows的桌面是由不同的二窗体构成，包括图标层，背景层，背景层显示桌面壁纸，图标层放置图标，且图标层背景透明，因此可以直接看到后面的背景层，鼠标右键弹出菜单也是在图标层完成。wallpaper在图标层和背景层之间插入了自己的窗口，因此可以显示动画，执行代码。前面已经提到图标层是一个透明的覆盖全屏的大窗口，因此鼠标事件只会在图标层响应，而wallpaper可以实时响应鼠标可能是利用了Hook拦截了鼠标事件，并加入自己代码。 既然知道了原理就可以自己实现。 首先创建两个窗体，一个用来播放视频，一个用来控制 上图是控制窗口，也是主窗口。 另一个视频窗口较为简单，直接用MediaPlayer覆盖全屏就行，注意需要设置WindowState为Maximized，即启动时立即最大化，同时播放器要隐藏ui，即设置uiMode为none。 在主窗体的load事件里新建VideoForm。为了让VideoForm能够夹在图标层和背景层中间，需要将VideoForm的父窗体设置为背景窗体。 现在需要查找背景窗体的句柄，使用窗口查看器发现背景窗体没有窗体名称，因此无法直接定位，但是我们知道它的类名是WorkW，它的父窗体是Program Manager，所以我们可以遍历所有WorkW窗体，如果其中一个窗体的父窗体是Program Manager，那么这个窗体就是背景窗体。 C#不支持直接这种接近底层的操作，因此需要调用user32.dll实现 [DllImport(\"user32.dll\", EntryPoint = \"SetParent\")] private static extern int SetParent(int hWndChild,int hWndNewParent); [DllImport(\"user32.dll\", EntryPoint = \"FindWindowA\")] private static extern IntPtr FindWindowA(string lpClassName, string lpWindowName); [DllImport(\"user32.dll\", EntryPoint = \"FindWindowExA\")] private static extern IntPtr FindWindowExA(IntPtr hWndParent, IntPtr hWndChildAfter, string lpszClass, string lpszWindow); [DllImport(\"user32.dll\", EntryPoint = \"GetClassNameA\")] private static extern IntPtr GetClassNameA(IntPtr hWnd, IntPtr lpClassName, int nMaxCount); [DllImport(\"user32.dll\", EntryPoint = \"GetParent\")] private static extern IntPtr GetParent(IntPtr hWnd); public static void SetFather(Form form) { SetParent((int)form.Handle, GetBackground()); } private static int GetBackground() { unsafe { IntPtr background = IntPtr.Zero; IntPtr father = FindWindowA(\"progman\", \"Program Manager\"); IntPtr workerW = IntPtr.Zero; do { workerW = FindWindowExA(IntPtr.Zero, workerW, \"workerW\", null); if (workerW != IntPtr.Zero) { char[] buff = new char[200]; IntPtr b = Marshal.UnsafeAddrOfPinnedArrayElement(buff, 0); int ret = (int)GetClassNameA(workerW, b, 400); if (ret == 0) throw new Exception(\"出错\"); } if (GetParent(workerW) == father) { background = workerW; } } while (workerW != IntPtr.Zero); return (int)background; } } 其中GetBackground函数负责查找背景层窗体，SetFather负责把一个窗体设置成另一个窗体的子窗体。为了使用指针功能，需要先开启不安全的代码功能 :项目—??属性(??是你的项目名称)—允许不安全代码。 这个方法在Windows 10 21H1 19043.1110上测试有效，但是不保证在其他系统有效，例如，在vista系统上就会返回空指针，这可能是因为vista系统上的背景窗体不满足上面所讲的关系。一旦返回空指针，会导致设置父窗体失败，最后视频会在图标层上方播放，此时的动态壁纸软件就彻底变成了一个全屏播放器。 如果遇到上面这种情况，可以使用MicrosoftSpy来查找背景窗体，并根据具体情况改写上面的代码。 这里利用了windows窗口的一个特性：如果A窗体在B窗体上面，那么A窗体也会在B窗体的子窗体上面。 给控制窗体的四个按钮写上事件 private void Form1_Load(object sender, EventArgs e) { main = new VideoForm(); player = main.player; Window.SetFather(main); main.Show(); } private void button1_Click(object sender, EventArgs e)//打开 { OpenFileDialog open = new OpenFileDialog(); open.Filter = \"媒体文件(所有类型)|*.mp4;*.mpeg;*.wma;*.wmv;*.wav;*.avi|所有文件|*.*\"; if (open.ShowDialog() == DialogResult.OK) { player.URL = open.FileName; } } private void button2_Click(object sender, EventArgs e)//播放 { player.Ctlcontrols.play(); } private void button3_Click(object sender, EventArgs e)//暂停 { player.Ctlcontrols.pause(); } private void button4_Click(object sender, EventArgs e)//退出 { main.Dispose(); System.Environment.Exit(0); } 其中main是视频播放窗体，player是播放器 运行 点击退出 虽然程序退出了，但是桌面变成了一张白纸，极其难看，目前暂不知道为什么会发生这种情况，个人猜测是windows考虑到背景是一张静态图，所以不会实时刷新，而刚刚被覆盖掉的地方就会保持最后一次刷新的颜色，刚才点击“退出”时，由于先dispose了视频播放窗体，导致背景变成白板，如果不点击“退出”，直接结束进程，那么背景就会变成黑板，因为MediaPlayer就是黑色的 既然如此，我们只需要让背景刷新一下就可以，显然在切换壁纸的时候，windows不得不刷新背景，所以我们可以先获取当前壁纸，然后把壁纸切换成当前壁纸，这样实际效果看起来没有任何变化，但是让windows为我们刷新了一次背景。 [DllImport(\"user32.dll\", EntryPoint = \"SystemParametersInfo\")] public static extern int SystemParametersInfo(int uAction, int uParam, StringBuilder lpvParam, int fuWinIni); public static bool Refresh() { StringBuilder wallpaper = new StringBuilder(200); SystemParametersInfo(0x73, 200, wallpaper, 0); int ret = SystemParametersInfo(20, 1, wallpaper, 3); if(ret != 0) { RegistryKey hk = Registry.CurrentUser; RegistryKey run = hk.CreateSubKey(@\"Control Panel\\Desktop\\\"); run.SetValue(\"Wallpaper\", wallpaper.ToString()); return true; } return false; } 改写“退出”按钮事件 private void button4_Click(object sender, EventArgs e)//退出 { main.Hide(); this.Hide(); Window.Refresh(); main.Dispose(); System.Environment.Exit(0); } 之所以先隐藏，是因为在dispose和refresh执行的空隙里会有一瞬间的白屏，如果先隐藏就可以避免这种情况。 因为视频壁纸需要常驻后台，而控制窗口不可能常驻桌面，所以我们需要改写它的Formclosing，取消窗体关闭事件，并隐藏窗体 private void Form1_FormClosing(object sender, FormClosingEventArgs e) { e.Cancel = true; this.Hide(); } 给窗体加上NotifyIcon控件，该控件可以显示任务栏角标，改写双击事件，双击角标时显示控制窗体 private void notifyIcon1_MouseDoubleClick(object sender, MouseEventArgs e) { this.Show(); } 到现在完整的Wallpaper已经制作完成，但是目前仅能播放视频。当然也包括图片，但是你需要设置MediaPlayer的循环播放，否则图片显示几秒后就会变成纯黑壁纸。 看看GPU占用情况 以上数据是我在播放电影《龙之谷精灵王座》时的资源占用情况，该电影共1.83GB，可以看到内存占用不到100MB，GPU0是核显，核显占用也才2%，比起wallpaper已经非常优秀了，但同时功能也非常单一，不过如果仅仅用来播放视频，完全可以用来替代wallpaper。 如果你想要实现更多好玩的功能，也可以往视频播放窗体里加别的东西，但是需要注意一点，所有需要交互的事件都不会响应，比如鼠标点击，你只能通过控制窗体来修改视频播放窗体的内容。 源代码:https://dearx.lanzoui.com/iiP4frxcm4d EXE文件:https://dearx.lanzoui.com/iIPmWrxcn6b EXE文件链接打开后是一个压缩包，里面包含两个dll和一个exe，这三个文件需要放在同一目录下才可以运行","categories":[{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/categories/Wallpaper/"},{"name":"C#","slug":"Wallpaper/C","permalink":"http://example.com/categories/Wallpaper/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/tags/Wallpaper/"}],"author":"DearXuan"},{"title":"针对内存修改的反作弊方法","slug":"针对内存修改的反作弊方法","date":"2021-07-25T05:51:00.000Z","updated":"2021-08-20T07:44:16.346Z","comments":true,"path":"2021/07/25/针对内存修改的反作弊方法/","link":"","permalink":"http://example.com/2021/07/25/%E9%92%88%E5%AF%B9%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%8D%E4%BD%9C%E5%BC%8A%E6%96%B9%E6%B3%95/","excerpt":"","text":"内存修改作弊是指用户修改内存数据来达到修改分数，金币，生命的作弊手段，这种作弊方法最常见，门槛也最低，只需要简单地掌握CE类修改器的使用方法即可。 源程序#include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; int score = 0; int main(){ int a,b,c,s; while (true){ a = rand() % 10; b = rand() % 10; c = a + b; system(\"cls\"); printf(\"当前分数:%d\\n\",score); printf(\"请计算:\\n\"); printf(\"%d + %d = ?\\n\",a,b); scanf(\"%d\",&amp;s); if(s == c){ score++; } else if(s &lt; 0){ break; } else{ score--; } } } 程序在屏幕上打印算式，并要求用户计算结果，计算正确加一分，否则扣一分。 作弊方法使用CE修改器，搜索分数 很快就搜索到了分数的地址 程序被修改 双重验证的反作弊方法设定另一个变量verify，将verify的值设定为score的10倍，如果发现score和verify对不上，则认定作弊 #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; int score = 0; int verify = 0; void AddScore(); void MinusScore(); void CheckCheating(); int main(){ int a,b,c,s; while (true){ a = rand() % 10; b = rand() % 10; c = a + b; system(\"cls\"); printf(\"当前分数:%d\\n\",score); printf(\"请计算:\\n\"); printf(\"%d + %d = ?\\n\",a,b); scanf(\"%d\",&amp;s); if(s == c){ AddScore(); } else if(s &lt; 0){ break; } else{ MinusScore(); } } } void AddScore(){ CheckCheating(); score++; verify = score * 10; } void MinusScore(){ CheckCheating(); score--; verify = score * 10; } void CheckCheating(){ if(score * 10 != verify){ MessageBox(NULL,\"禁止作弊!\",\"AntiCheat\",MB_OK); exit(0); } } 改变地址来避免定位定义指针p指向分数，每次修改分数时都重新申请内存空间，并释放老的空间，这样会让CE类修改器无法找到分数的地址，自然就无法修改，但是可能会造成系统开销过多，大量使用指针还容易造成内存泄漏 #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; int *p; int main(){ p = (int*) malloc(sizeof(int)); *p = 0; int a,b,c,s; int *last; while (true){ a = rand() % 10; b = rand() % 10; c = a + b; system(\"cls\"); printf(\"当前分数:%d\\n\",*p); printf(\"请计算:\\n\"); printf(\"%d + %d = ?\\n\",a,b); scanf(\"%d\",&amp;s); if(s == c){ last = p; p = (int*) malloc(sizeof(int)); *p = *last + 1; } else if(s &lt; 0){ break; } else{ last = p; p = (int*) malloc(sizeof(int)); *p = *last - 1; } free(last); } } 自定义结构使用不寻常的方式来保存数据，加大作弊难度。 #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; int score1 = 0; int score2 = 0; int GetScore(); void SetScore(int score); int main(){ int a,b,c,s; while (true){ a = rand() % 10; b = rand() % 10; c = a + b; system(\"cls\"); printf(\"当前分数:%d\\n\",GetScore()); printf(\"请计算:\\n\"); printf(\"%d + %d = ?\\n\",a,b); scanf(\"%d\",&amp;s); if(s == c){ SetScore(GetScore() + 1); } else if(s &lt; 0){ break; } else{ SetScore(GetScore() - 1); } } } int GetScore(){ return score1 * 10 + score2; } void SetScore(int score){ score1 = score / 10; score2 = score % 10; } 上述代码将分数分成两部分:score1和score2，真实的分数是score1*10+score2，如果作弊者仍然搜索真实分数，就会得到错误的地址。这仅仅是一种简单的示范，实际上我们可以自定义许多复杂的结构，加大破解难度。例如 struct Num{ bool n1:1; bool n2:1; bool n3:1; bool n4:1; bool n5:1; bool n6:1; bool n7:1; bool n8:1; }; C++中的布尔变量占用一个字节，但是实际上的布尔类型仅需要一位，将8个布尔类型变量放在一个结构体里面，这个结构体占一位，此时一般的修改器会将这8个布尔变量误认为是一个数，经过测试，CE修改器成功被骗到，当八个布尔变量都为true时会将Num识别为数字255. 加密保存将数据经过处理后保存，这样的处理可以是简单的加减乘除，也可以是复杂的加密 #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; int score = 0; int GetScore(); void SetScore(int s); int main(){ int a,b,c,s; while (true){ a = rand() % 10; b = rand() % 10; c = a + b; system(\"cls\"); printf(\"当前分数:%d\\n\",GetScore()); printf(\"请计算:\\n\"); printf(\"%d + %d = ?\\n\",a,b); scanf(\"%d\",&amp;s); if(s == c){ SetScore(GetScore() + 1); } else if(s &lt; 0){ break; } else{ SetScore(GetScore() - 1); } } } int GetScore(){ return -score / 10; } void SetScore(int s){ score = -s * 10; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"反作弊","slug":"反作弊","permalink":"http://example.com/tags/%E5%8F%8D%E4%BD%9C%E5%BC%8A/"}],"author":"DearXuan"},{"title":"PVZ逆向分析与C#内存操作(含源文件)","slug":"PVZ逆向分析与C-内存操作","date":"2021-07-19T11:03:00.000Z","updated":"2021-08-20T07:43:18.537Z","comments":true,"path":"2021/07/19/PVZ逆向分析与C-内存操作/","link":"","permalink":"http://example.com/2021/07/19/PVZ%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%8EC-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/","excerpt":"","text":"首先打开植物大战僵尸，进入游戏，初始阳光为50.打开CE修改器，搜索50进入游戏，种植向日葵，阳光变成0，再次搜索再进入游戏，收取阳光，阳光变成25，搜索25显然地址0x144344C8保存的就是阳光，现在退出游戏重新打开，重复上面步骤现在地址变成0x1408EDC0了，说明阳光的地址并不是固定的。对这个地址进行检测，查看是哪条指令在修改我刚刚进行了种植和收集阳光两个步骤，显然mov是减少阳光，add是增加阳光。查看详细信息得到EAX = 0x14089860，这个0x5560其实就是二级偏移.然而EAX也是动态变化的，我们需要在内存中搜索EAX，来查找它到底保存在哪个地方由于这个地址保存了阳光的地址，所以它应该是不变的，否则就找不到阳光的地址了，所以可以多次重复扫描，确保把会改变的量排除。逐一查看哪个操作码访问了上面地址，发现地址0x028CA730很有趣列表里清一色的都是0x768，证明[EAX + 0x028CA730]保存了结构体地址，查看EAX地址这里不管是查看EAX还是ECX，结果肯定是一样的，因为它们都指向同一个地址，且偏移也相同。EAX = 0x028C9FC8，而0x768就是一级偏移。继续搜索EAX列表里出现绿色的基址，查找结束。开始写代码，C#无法直接修改内存，需要动态调用kernel32.dll [DllImport(\"kernel32.dll\", EntryPoint = \"OpenProcess\")] public static extern IntPtr OpenProcess(int desiredAccess, bool heritHandle, int pocessID); [DllImport(\"kernel32.dll\", EntryPoint = \"CloseHandle\")] public static extern void CloseHandle(IntPtr hObject); [DllImport(\"kernel32.dll\", EntryPoint = \"ReadProcessMemory\")] public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr baseaddress, IntPtr buffer, int nsize, IntPtr bytesread); [DllImport(\"kernel32.dll\", EntryPoint = \"WriteProcessMemory\")] public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr baseaddress, long[] buffer, int nSize, IntPtr byteswrite); 读写内存需要用到OpenProcess，官方文档里告诉我们第一个参数是访问权限，PROCESS_ALL_ACCESS指所有能获得的最高权限，但是PROCESS_ALL_ACCESS是在C++里定义的，C#里却没有，注意到这个值的类型是int，我们可以在C++里打印出这个值，然后直接写在C#里所以我们只要输入0x1F0FFF就行了 private int ReadMemory(int pid,IntPtr toBase) { byte[] bytes = new byte[4]; IntPtr address = Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0); IntPtr process = OpenProcess(0x1F0FFF, false, pid); ReadProcessMemory(process, toBase, address, 4, IntPtr.Zero); CloseHandle(process); return Marshal.ReadInt32(address); } private void WriteMemory(int pid,IntPtr toBase,int num) { IntPtr process = OpenProcess(0x1F0FFF, false, pid); WriteProcessMemory(process, toBase, new long[] { num }, 4, IntPtr.Zero); CloseHandle(process); } 获取进程PID private int GetPid() { Process[] processes = Process.GetProcessesByName(ProcessName); if(processes.Length == 0) { ShowDialog(\"没有检测到游戏进程.\"); return -1; } if(processes.Length &gt; 1) { ShowDialog(\"检测到多个进程，这可能是因为您开启了多个相同进程名的软件，请关闭多余软件.\"); return -1; } return processes[0].Id; } 定义全局变量 private const string ProcessName = \"PlantsVsZombies\";//进程名称 private const int sun = 9990;//每次修改的阳光数值 private int pid;//进程PID private IntPtr intPtr;//阳光的地址 获取进程信息 private void GetInfo() { pid = GetPid(); if (pid == -1) return; int num1 = ReadMemory(pid, (IntPtr)0x006A9EC0); int num2 = ReadMemory(pid, (IntPtr)(num1 + 0x768)); intPtr = (IntPtr)(num2 + 0x5560); } 添加两个按钮，第一个按钮用来读取进程信息，第二个按钮用来修改阳光 private void button1_Click(object sender, EventArgs e) { GetInfo(); } private void button2_Click(object sender, EventArgs e) { WriteMemory(pid, intPtr, sun); } 修改成功关闭植物大战僵尸，重新打开，再次尝试。修改成功，修改器制作完成。接下来是优化MemoryIO.cs using System; using System.Collections.Generic; using System.Diagnostics; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; namespace PVZ_Cheater { static class MemoryIO { [DllImport(\"kernel32.dll\", EntryPoint = \"OpenProcess\")] public static extern IntPtr OpenProcess(int desiredAccess, bool heritHandle, int pocessID); [DllImport(\"kernel32.dll\", EntryPoint = \"CloseHandle\")] public static extern void CloseHandle(IntPtr hObject); [DllImport(\"kernel32.dll\", EntryPoint = \"ReadProcessMemory\")] public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr baseaddress, IntPtr buffer, int nsize, IntPtr bytesread); [DllImport(\"kernel32.dll\", EntryPoint = \"WriteProcessMemory\")] public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr baseaddress, long[] buffer, int nSize, IntPtr byteswrite); public static int GetPid(string ProcessName) { Process[] processes = Process.GetProcessesByName(ProcessName); if (processes.Length == 0) { throw new Exception(\"没有检测到游戏进程.\"); } if (processes.Length &gt; 1) { throw new Exception(\"检测到多个进程，这可能是因为您开启了多个相同进程名的软件，请关闭多余软件.\"); } return processes[0].Id; } public static int ReadMemory(int pid, IntPtr toBase) { byte[] bytes = new byte[4]; IntPtr address = Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0); IntPtr process = OpenProcess(0x1F0FFF, false, pid); ReadProcessMemory(process, toBase, address, 4, IntPtr.Zero); CloseHandle(process); return Marshal.ReadInt32(address); } public static void WriteMemory(int pid, IntPtr toBase, int num) { IntPtr process = OpenProcess(0x1F0FFF, false, pid); WriteProcessMemory(process, toBase, new long[] { num }, 4, IntPtr.Zero); CloseHandle(process); } } } PVZInfo.cs using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace PVZ_Cheater { static class PVZInfo { public const string ProcessName = \"PlantsVsZombies\"; public static int Pid; public static IntPtr Sun_Address; public static int Sun_Value = 9990; public static bool isReady = false; public static void GetInfo() { isReady = false; Pid = MemoryIO.GetPid(ProcessName); int num1 = MemoryIO.ReadMemory(Pid, (IntPtr)0x006A9EC0); int num2 = MemoryIO.ReadMemory(Pid, (IntPtr)(num1 + 0x768)); Sun_Address = (IntPtr)(num2 + 0x5560); isReady = true; } public static void SetSun() { if(isReady) MemoryIO.WriteMemory(Pid, Sun_Address, Sun_Value); } } } 增加一个Timer计时器，当选中”锁定阳光”选项时，每隔1秒将阳光赋值为9990，成功实现无限阳光 源文件:https://dearx.lanzoui.com/ibVLJrm95be","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"逆向分析","slug":"逆向分析","permalink":"http://example.com/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"内存读写","slug":"内存读写","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/"}],"author":"DearXuan"},{"title":"C#序列化对象的二进制储存方法及底层原理研究","slug":"C-序列化对象的二进制储存方法及底层原理研究","date":"2021-07-19T01:55:00.000Z","updated":"2021-08-20T07:43:07.266Z","comments":true,"path":"2021/07/19/C-序列化对象的二进制储存方法及底层原理研究/","link":"","permalink":"http://example.com/2021/07/19/C-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%82%A8%E5%AD%98%E6%96%B9%E6%B3%95%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/","excerpt":"","text":"在硬盘里保存txt或二进制文件非常容易，当需要保存的对象是一个自定义类的对象时，此时采用txt或二进制存储都较为复杂，如果采用txt形式，那么在保存非文本的数据时，需要手动转换，并且txt非常容易修改。保存为二进制文件较为简单，C#还提供了int32,byte等类型的读写方法，可以直接使用，但是仍有弊端，即代码复杂，你需要不断地读取，赋值。 实际上C#提供了序列化存储的方法，可以轻松地把一个对象保存到硬盘里。 首先定义一个类，并在最前面加上”[Serializable]”，表示这个类可以序列化 [Serializable] class Struct { public string a { get; set; } public string b { get; set; } public int s { get; set; } } 引入命名空间System.Runtime.Serialization.Formatters.Binary和System.IO 实例化对象@struct，并保存在D:\\abc.txt static void Save() { Struct @struct = new Struct(); @struct.a = \"123\"; @struct.b = \"ABCD\"; @struct.s = 27; using (FileStream fileStream = new FileStream(@\"D:\\abc.txt\", FileMode.OpenOrCreate)) { BinaryFormatter binaryFormatter = new BinaryFormatter(); binaryFormatter.Serialize(fileStream, @struct); } } 从硬盘读取 static void Read() { using(FileStream fileStream = new FileStream(@\"D:\\abc.txt\", FileMode.OpenOrCreate)) { BinaryFormatter binaryFormatter = new BinaryFormatter(); Struct @struct = binaryFormatter.Deserialize(fileStream) as Struct; Console.WriteLine(@struct.a); Console.WriteLine(@struct.b); Console.WriteLine(@struct.s); } } 运行结果 现在开始研究底层原理 首先给这个类加上一个变量k [Serializable] class Struct { public string a { get; set; } public string b { get; set; } public int s { get; set; } public int k { get; set; } } 执行Read方法，发现竟然读取成功了，但是k并没有被赋值 我们再给他加上一个方法ABC class Struct { public string a { get; set; } public string b { get; set; } public int s { get; set; } public int k { get; set; } public void ABC() { k++; } } 现在这个类的结果已经完全改变，但是执行了Read方法后发现仍然读取成功了。 现在我们修改其中一个变量名，把s改成ss [Serializable] class Struct { public string a { get; set; } public string b { get; set; } public int ss { get; set; } } 执行结果 最后我们把类名Struct改成Struct1\\ [Serializable] class Struct1 { public string a { get; set; } public string b { get; set; } public int s { get; set; } } 不出所料地失败了 到这里已经基本可以看出序列化储存地原理，C#采用了类似XML文件地方法，将类名，变量名与变量值保存到一起。 将保存的文件以二进制形式打开 搜索字符串”123” 发现就在这个字符串的后面出现了连续的41到45，很明显这就是”ABCDE”的ASCII码，只不过是16进制的，换成10进制就看着舒服多了 同时我们还注意到这些字符串的前面都有一个数字恰好是后面的字符串长度 例如: “03”代表后面3个字节是字符串，但是为什么”03”前面还有3个”00”？在VS里随意输入一个字符串.Length，查看Length的类型 Length返回的是int类型，这说明string的最大长度不会超过int的最大值，int是int32的别名，从名字就能看出int32占了32位，恰好是4个字节，这也证明string的储存形式是 “长度+内容” 继续往后看，最后面还有一个int类型的数字27，但是这个27的位置很奇怪，他居然是靠左的，而刚刚还是靠右的。为了进一步研究，我们把27改成999999999 现在的十六进制码是 FF C9 9A 3B。通过其他软件进制转换，发现正确的十六进制码应该是 3B 9A C9 FF。恰好是上面的反转。 我们再把int改成long，并把数字改成99999999999999999，再次尝试。 软件中是：FF FF 89 5D 78 45 63 01 实际上是：01 63 45 78 5D 89 FF FF 已经足够肯定C#会将数字倒序输出。但是这样不是多此一举吗？大家是否还记得在进制转换时需要不断计算余数，最后把余数倒序排列？并且这个规律只在16进制出现，合理猜测C#在保存数值类型数据时会把数字转化成16进制来保存，并且没有倒序输出。而十六进制转十进制时，也是需要从右往左来读取，第一个数的权值是1，第二个数是16，第三个是16^2。不管是保存还是读取，都是需要从右往左的，因为右边是最低位。 生活中进制转换需要把余数倒序排列，因为我们的数字是高位在左，低位在右，而计算机储存时显然不需要遵守这个规律，它可以令高位在右，低位在左，这样就省去了倒序输出这一步，并且也符合了文件流操作从左到右的顺序。 至于为什么选择16进制，而不是二进制，可能是为了效率，同样的一个数2^16，如果除以16，则只需要计算4次，但是如果除以2，则需要计算16次，效率相差了4倍。但是最终不是还要用二进制保存吗？是不是还需要把16进制转成2进制？如果是我们自己写代码，可能真的需要多转换一次，但是计算机是以2进制保存数据，除法的底层原理是位移计算，计算结果也是2进制数，所以计算机并不需要额外转换一次。 想到这里，看似已经真相大白，但是又出现了新的问题，我们输入的数字在内存里也是二进制形式，计算机可以直接把这个二进制形式的数字从左到右保存到文件里，为什么要多此一举先转换成10进制，再转成16进制？ 接下来我们用C++进行下一步实验 图中可以看到，我在计算机中保存了0x11223344这个数字，尽管我输入的是16进制，但是内存里仍然是按int类型储存。C++中的char只占了一个字节，所以我们定义一个char指针，把他指向a，此时p指向的是a的第一个字节，顺序打印p,p+1,p+2,p+3位置的数据，发现结果是 44 33 22 11。 这样的结果与我们的输入完全相反，但同时也证明了int在内存中是倒序存放的(相对于人类是倒序)。与上面的猜想相联系，最终得出答案：数字在内存中是以字节为单位倒序保存的，这样保存的优点在于可以从低位到高位的读取方向与流操作从左到右的方向相同，加快了读取速度。 最后回到一开始的问题上来，我们已经研究了变量在序列化操作中的保存方法。如果刚刚仔细观察，会发现文件末尾总是 0B，由此我们可以大胆猜测这是结束符。我们还发现字符串的前面除了有四个字节用来表示数字以外，还有两个字节 06 03，以及第二个字符串前面的 06 04，如果你在类里面多定义一个字符串，你会发现字节码里多出一个 06 05，因此我们也可以大胆猜测这是字符串标志。为了进一步验证这个猜想，我们把前面的0603改成0604，把后面的0604改成0603，重新读取，发现能够正常读取，而如果把前面的06改成07，就无法读取了，可以证明06是标识符。后面的数据是按顺序存储的，而不是采用指针的方法。 到这里已经基本搞清楚变量的储存结构了，前面一长串的字节可以直接用txt格式打开，能够发现其中夹杂着Version,PublicKeyToken,Struct等，这些数据表明了版本，类的结构，类里面的变量名等数据，用来判断类的格式。后面紧跟着的是变量，变量与前面的变量名按顺序一一对应，最后一位是0B，表示文件流结束。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"序列化对象","slug":"序列化对象","permalink":"http://example.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1/"},{"name":"二进制","slug":"二进制","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"底层原理","slug":"底层原理","permalink":"http://example.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"}],"author":"DearXuan"},{"title":"C#实现简易XML阅读器(含源文件和exe文件)","slug":"C-实现简易XML阅读器","date":"2021-07-14T13:01:00.000Z","updated":"2021-08-20T07:42:54.218Z","comments":true,"path":"2021/07/14/C-实现简易XML阅读器/","link":"","permalink":"http://example.com/2021/07/14/C-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93XML%E9%98%85%E8%AF%BB%E5%99%A8/","excerpt":"","text":"功能本程序的主要目的是便于阅读XML文件。在网上复制一些XML文本时，常常出现格式错误，更有甚者，整个文本就一行，一行有几百个字符。这些奇奇怪怪的格式大大增加了理解难度，本程序将模仿记事本，提供基础的文件读写，编辑功能，并在此基础上增加了格式对齐和高亮功能。 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;Class&gt; &lt;Student&gt; &lt;ID&gt;1111&lt;/ID&gt; &lt;name&gt;Happy&lt;/name&gt; &lt;/Student&gt; &lt;Student&gt; &lt;ID&gt;2222&lt;/ID&gt; &lt;name&gt;Sad&lt;/name&gt; &lt;/Student&gt; &lt;/Class&gt; 界面设计主界面分为菜单栏和输入框 文件读写新建FileIO.cs，引入命名空间System.IO static class FileIO { public static string ReadFile(string path) { if (path == null) return null; string line; string s = \"\"; StreamReader streamReader = null; try { streamReader = new StreamReader(path); while((line = streamReader.ReadLine()) != null) { s += line + \"\\n\"; } } catch(Exception ex) { s = null; } finally { if (streamReader != null) streamReader.Dispose(); } return s; } public static bool WriteFile(string path,string content) { StreamWriter streamWriter = null; try { streamWriter = new StreamWriter(path); streamWriter.Write(content); } catch(Exception ex) { return false; } finally { if (streamWriter != null) streamWriter.Dispose(); } return true; } } ReadFile函数根据传入的地址，读取文件内容，WriteFile则负责保存文件，返回的布尔值用于判断是否保存成功。有人可能会对WriteFile里的catch产生疑惑，在catch里直接return了，那finally的代码不就无法执行了吗？实际上在执行return之前，会先把要return的数据保存，然后执行finally里的语句，最后再return刚刚保存的参数。例如我在catch里return a，而a=1，即使我在finally里把a赋值成2，那最后返回的仍然是1. 查找和替换DFA算法可以极大提高长字符串的查找效率 public bool textHasChanged = true; public bool wordHasChanged = true; private char[] word; private char[] text; private bool GetWord() { if(main.richTextBox1.Text.Length == 0) { MessageBox.Show(\"文本内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if(textBox1.Text.Length == 0) { MessageBox.Show(\"查找内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if (textHasChanged) { if (checkBox1.Checked)//不区分大小写 { text = main.richTextBox1.Text.ToLower().ToCharArray(); } else { text = main.richTextBox1.Text.ToCharArray(); } textHasChanged = false; } if (wordHasChanged) { if (checkBox1.Checked)//不区分大小写 { word = textBox1.Text.ToLower().ToCharArray(); } else { word = textBox1.Text.ToCharArray(); } wordHasChanged = false; } return true; } 首先定义char数组word和text，分别表示需要查找的内容和全部文本，使用ToCharArray()将string转化成char数组，在实际使用中，常常会连续使用多次查找功能，如果每次查找时都要转换以下，会增大系统开销，因此需要设定布尔变量来表示字符串内容是否被修改，仅当用户手动修改了word或者text内容时才重新转换。其中“查找”按钮就是简单的统计字符串在文本中出现了多少次，并选中第一次出现的位置，实现较为容易，不展示源码。“上一处”和“下一处”则要根据鼠标光标的位置寻找上一个或下一个出现的位置 private void button2_Click(object sender, EventArgs e)//向下查找 { if (!GetWord()) return; int i, j; bool flag; if (checkBox1.Checked) { flag = main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower()); } else { flag = main.richTextBox1.SelectedText.Equals(textBox1.Text); } if (flag) { i = main.richTextBox1.SelectionStart + main.richTextBox1.SelectionLength; } else { i = main.richTextBox1.SelectionStart; } if (i == text.Length) i = 0; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &lt; text.Length &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i + j &lt; text.Length &amp;&amp; text[i + j] == word[j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i, j); main.Focus(); return; } } i += j + 1; alreadySearchLength += j + 1; if (i &gt;= text.Length &amp;&amp; checkBox2.Checked) i = 0; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None); } 查找之前使用Getword()来获取最新的char数组，此时还要考虑一种情况，假设用户需要查找”abc”，并且用户当前已经选中”abc”，就需要将起始位置设置为光标位置的后3格。同时如果用户勾选了”循环”，则变量 i 超出文本长度时，需要将它设置为0，但是这又会引起另一个问题：死循环。为了防止出现死循环，可以设置一个变量alreadySearchLength，这个变量记录已经查找过的字符串长度，当这个变量超过文本长度时，说明已经遍历了全部字符，则退出循环。查找采用了DFA算法，将需要查找的字符串的首字符跟text数组比较，遇到相同的再比较下一个，这样可以减少查找所用时间。向下查找和向上查找代码大致相同，但是向上查找不需要判断当前选中字符串是否就是需要查找的字符串。 private void button3_Click(object sender, EventArgs e)//向上查找 { if (!GetWord()) return; int i = main.richTextBox1.SelectionStart,j; if (i == 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; if (i == text.Length) i = text.Length - 1; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &gt;= 0 &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i - j &gt;= 0 &amp;&amp; text[i - j] == word[word.Length - 1 - j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i - j + 1, j); main.Focus(); return; } } i -= j + 1; alreadySearchLength += j + 1; if (i &lt;= 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None); } private void button1_Click(object sender, EventArgs e)//替换 { if (checkBox1.Checked) { if (main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower())) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if(start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if(start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } } else { if (main.richTextBox1.SelectedText.Equals(textBox1.Text)) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if (start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if (start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } } } 替换比起查找较为复杂，首先是判断当前选中字符串是否就是要替换的内容，如果是，替换当前选中的文本，并选中下一个出现的位置；如果不是，直接选中下一个出现的位置。替换是利用字符串截取功能实现的，因此在替换前需要先保存光标位置，替换后再重设光标位置。 对齐与高亮对齐可以使用C#自带的XmlTextWriter来实现，注意命名空间为System.Xml高亮比之前的查找和替换简单，只需要根据尖括号来查找就行，并将尖括号里的内容设置为蓝色 if (richTextBox1.Text.Trim().Equals(\"\")) { MessageBox.Show(\"内容为空.\", \"对齐\"); return; } try { XmlDocument document = new XmlDocument(); document.LoadXml(richTextBox1.Text); MemoryStream memoryStream = new MemoryStream(); XmlTextWriter writer = new XmlTextWriter(memoryStream, null) { Formatting = Formatting.Indented }; document.Save(writer); StreamReader streamReader = new StreamReader(memoryStream); memoryStream.Position = 0; string xmlString = streamReader.ReadToEnd(); streamReader.Close(); memoryStream.Close(); richTextBox1.Text = xmlString; } catch(Exception ex) { MessageBox.Show(ex.Message); } 启动参数为了实现快捷打开文本文件，需要程序读取启动参数并在启动后立即打开参数指定的文件 public Form1(string[] args) { InitializeComponent(); if(args.Length != 0) { filePath = args[0]; if (!filePath.EndsWith(\".txt\")) { switch(MessageBox.Show(\"XML Reader仅支持文本文件，是否以文本形式打开\" + filePath + \"?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None)) { case DialogResult.OK: break; case DialogResult.No: filePath = null; return; case DialogResult.Cancel: System.Environment.Exit(0); break; } } string content = FileIO.ReadFile(filePath); if (content == null) { filePath = null; } else { LoadXML(content); } } } 注意string[] args并不是自动生成的，而是我手动加上去的，首先在程序入口点Program.Main里获取args，然后再传递给主窗体 static class Program { /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main(string[] args) { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1(args)); } } 拖拽事件当用户手动拖入某个文件时，快捷打开该文件事件窗口里并没有为我们提供拖拽事件，因此我们需要自己手动定义一个 richTextBox1.AllowDrop = true; richTextBox1.DragDrop += new DragEventHandler(richTextBox1_DragDrop); 改写DragDrop函数 private void richTextBox1_DragDrop(object sender, DragEventArgs e) { string[] files = (string[])e.Data.GetData(DataFormats.FileDrop); if (files.Length == 0) return; string file = files[0]; if (Path.GetExtension(file).Equals(\".txt\")) { string s = FileIO.ReadFile(file); if(s == null) { MessageBox.Show(\"读取失败.\", \"XML Reader\", MessageBoxButtons.OK, MessageBoxIcon.Information); return; } else { if (!isSaved) { DialogResult result = MessageBox.Show(\"你想将更改保存到\" + Text + \"吗?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None); switch (result) { case DialogResult.OK: 保存ToolStripMenuItem_Click(null, null); break; case DialogResult.No: break; case DialogResult.Cancel: return; } } LoadXML(s); } } else { MessageBox.Show(\"该类型的文件不被支持.\", \"XML Reader\"); } } 最终成果 源文件EXE程序:https://dearx.lanzoui.com/ioNRKrez29c源文件:https://dearx.lanzoui.com/i7bWzrez2fi","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"exe项目","slug":"C/exe项目","permalink":"http://example.com/categories/C/exe%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"}],"author":"DearXuan"},{"title":"利用RSA加密实现的简易离线验证功能(C#,含代码)","slug":"利用RSA加密实现的简易离线验证功能","date":"2021-07-13T14:02:00.000Z","updated":"2021-08-20T07:43:00.976Z","comments":true,"path":"2021/07/13/利用RSA加密实现的简易离线验证功能/","link":"","permalink":"http://example.com/2021/07/13/%E5%88%A9%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"许多软件都有正版验证功能，它们通常需要联网验证，验证的本质则是加密与解密，本文将使用RSA加密算法实现简易的离线验证功能 RSA加密设p,q是两个超级大的素数，N=pq，数据通过欧拉函数φ(N)来加密，而欧拉函数φ(N)满足φ(N)= φ(pq)=(p-1)(q-1)，如果要算出φ(N)，就必须知道p和q。并且这有一点好处，某人可以公开宣布他的密钥e以及N，任何人都可以给他发送密文，但是只有他能看懂。因为想要破解密码，就必须知道那两个超级大素数p,q.p和q的位数决定了密文的安全性。 硬件绑定由于是离线验证，所以我们能很容易想到可以根据电脑的硬件信息生成一串加密字符串，程序根据加密字符串解密出硬件信息，如果解密出来的信息与实际电脑配置信息相同，则认为验证通过。同时我们还可以在字符串上添加一些额外信息，例如有效期，这样就能做到限定时间的功能。这里以BIOS为例，使用ManagementClass和ManagementObjectCollection读取硬件信息，注意这两个类的命名空间为System.Management ManagementClass mc = null; ManagementObjectCollection moc = null; try { mc = new ManagementClass(\"Win32_BIOS\"); moc = mc.GetInstances(); foreach (ManagementObject mo in moc) { bios = mo.Properties[\"SerialNumber\"].Value.ToString(); break; } } catch(Exception ex) { bios = null; } finally { if (mc != null) mc.Dispose(); if (moc != null) moc.Dispose(); } 程序读取了BIOS编号，并保存在bios字符串中现在根据BIOS编号生成密文，C#提供了RSACryptoServiceProvider来帮助加密，注意这个类的命名空间为System.Security.Cryptography public static string Encrypt(string content) { string publickey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(publickey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false); return Convert.ToBase64String(cipherbytes); } public static string Decrypt(string content) { string privatekey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/hf2dnK7rNfl3lbqghWcpFdu778hUpIEBixCDL5WiBtpkZdpSw90aERmHJYaW2RGvGRi6zSftLh00KHsPcNUMw==&lt;/P&gt;&lt;Q&gt;6Cn/jOLrPapDTEp1Fkq+uz++1Do0eeX7HYqi9rY29CqShzCeI7LEYOoSwYuAJ3xA/DuCdQENPSoJ9KFbO4Wsow==&lt;/Q&gt;&lt;DP&gt;ga1rHIJro8e/yhxjrKYo/nqc5ICQGhrpMNlPkD9n3CjZVPOISkWF7FzUHEzDANeJfkZhcZa21z24aG3rKo5Qnw==&lt;/DP&gt;&lt;DQ&gt;MNGsCB8rYlMsRZ2ek2pyQwO7h/sZT8y5ilO9wu08Dwnot/7UMiOEQfDWstY3w5XQQHnvC9WFyCfP4h4QBissyw==&lt;/DQ&gt;&lt;InverseQ&gt;EG02S7SADhH1EVT9DD0Z62Y0uY7gIYvxX/uq+IzKSCwB8M2G7Qv9xgZQaQlLpCaeKbux3Y59hHM+KpamGL19Kg==&lt;/InverseQ&gt;&lt;D&gt;vmaYHEbPAgOJvaEXQl+t8DQKFT1fudEysTy31LTyXjGu6XiltXXHUuZaa2IPyHgBz0Nd7znwsW/S44iql0Fen1kzKioEL3svANui63O3o5xdDeExVM6zOf1wUUh/oldovPweChyoAdMtUzgvCbJk1sYDJf++Nr0FeNW1RB1XG30=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privatekey); cipherbytes = rsa.Decrypt(Convert.FromBase64String(content), false); return Encoding.UTF8.GetString(cipherbytes); } 两部分核心代码已经完成，在程序中先获取BIOS编号，然后提示用户输入许可证，这个许可证实际上就是密文，程序解密密文，这里需要注意的是，如果用户输入的密文格式有误，则解密函数会抛出异常，因此需要套上try来执行，如果发生异常，则一律认为验证失败。以下是程序界面 文件读写验证模块已经完成，但是每次打开都要用户手动输入许可证，及其繁琐，因此我们需要将许可证保存在本地。首先在D盘创建ducuments目录，在document里创建LICENSE文件，注意需引入命名空间System.IO定义地址 private static string dirname = @\"D:\\documents\"; private static string filename = \"LICENSE.dx\"; private static string path = System.IO.Path.Combine(dirname, filename); 创建目录和文件，这里需注意Create后必须dispose，否则接下来读取时会提示被占用 System.IO.Directory.CreateDirectory(dirname); if (!File.Exists(path)) { FileStream fileStream = System.IO.File.Create(path); fileStream.Dispose(); } 读取和写入 public static string ReadFile() { string key = \"\"; string line; StreamReader sr = null; try { sr = new StreamReader(path); while ((line = sr.ReadLine()) != null) { key += line; } } catch(Exception ex) { key = null; } finally { if(sr != null) { sr.Dispose(); } } return key; } public static void WriteFile(string key) { StreamWriter sw = null; try { sw = new StreamWriter(path); sw.Write(key); } catch (Exception ex) { } finally { if (sw != null) { sw.Dispose(); } } } StreamReader和StreamWriter可以放在using里面执行，这样就会自动销毁，但是为了显示dispose的重要性，本程序中手动disposeStreamReader将许可证以文本形式写入文件里，而读取也是文本形式读取，所以文件的后缀名可以随便取。","categories":[{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"RSA加密","slug":"RSA加密","permalink":"http://example.com/tags/RSA%E5%8A%A0%E5%AF%86/"},{"name":"离线验证","slug":"离线验证","permalink":"http://example.com/tags/%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81/"}],"author":"DearXuan"},{"title":"DFA算法-简易Java敏感词过滤(含源文件和上万敏感词列表)","slug":"DFA算法-简易Java敏感词过滤","date":"2021-07-11T14:39:00.000Z","updated":"2021-08-20T07:22:05.471Z","comments":true,"path":"2021/07/11/DFA算法-简易Java敏感词过滤/","link":"","permalink":"http://example.com/2021/07/11/DFA%E7%AE%97%E6%B3%95-%E7%AE%80%E6%98%93Java%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/","excerpt":"","text":"敏感词过滤说白了就是简单的字符串替换，Java本身已经提供了相关函数，但是一旦遇到长文本，或者敏感词数量庞大，效率下降就会非常明显。本文将介绍利用多叉树进行敏感词存储和过滤的方法。 多叉树多叉树是一种特殊的数据结构，如下图Head为头节点，下面的ABCDE均为子树。那么多叉树是如何存储敏感词的呢？首先将敏感词分解为一个一个的字符，例如敏感词”CSDN”，第一个字符是C，则在Head下创建子树”C”(如果已经存在则跳过这一步)。第二个字符是S，则在子树”C”下面创建”S”接下来是D，N，创建完N就可以结束了。如此循环，就可以创建出类似上图的多叉树。检测敏感词时，对于字符串中的每一个字符，先查找Head下是否有存在对应子树，例如字符串”ELN”，先读取第一个字符E，并检查Head，发现存在子树”E”；于是读取第二个字符L，并检查子树E的子树，发现存在L；最后读取第三个字符N，发现子树N还是存在。此时发现子树N后面没有内容，这说明ELN是一个敏感词，于是将ELN替换成”***“。这种算法会出现一个小意外，如果一个敏感词恰好是另一个敏感词的前缀，就会导致较短的敏感词被长的敏感词覆盖，这种情况可以通过添加结束标记来区分。不过我的想法是，如果出现这种情况，直接把前缀屏蔽掉就行了，这样后半段也不算敏感词了(好像实际工作中不能这样做)，因此我没有添加结束标记。 代码首先要先写一个数据结构来模拟多叉树，下图里Word就是一颗树，里面保存着当前字符c和子树next，compareTo是用来排序的，以提高查找效率。 public class Word implements Comparable&lt;Word&gt;{ public char c; public List next = null; public Word(char c){ this.c = c; } @Override public int compareTo(Word word) { return c - word.c; } } 上图的List继承了ArrayList，主要是因为ArrayList可以动态添加元素，便于偷懒 import java.util.ArrayList; public class List extends ArrayList&lt;Word&gt; { public Word get(char c){ for(Word w :this){ if(w.c == c) return w; } return null; } /** * 二分查找，必须先升序排序 * @param c 需要查找的字符 * @return Word对象：如果找到 null:如果没找到 */ public Word binaryGet(char c){ int left,right,key; Word word; left = 0;right = this.size()-1; while (left &lt;= right){ key = (left + right) / 2; word = get(key); if(word.c == c){ return word; }else if(word.c &gt; c){ right = key - 1; }else { left = key + 1; } } return null; } public Word add(char c){ Word word = new Word(c); super.add(word); return word; } } 以下是核心代码 import java.io.*; import java.util.ArrayList; import java.util.Collections; public final class SensitiveWordFilter { public static List wordList; private final static char replace = '*'; // 替代字符 private final static char[] skip = new char[]{ // 遇到这些字符就会跳过，例如,如果\"AB\"是敏感词，那么\"A B\",\"A=B\"也会被屏蔽 '!','*','-','+','_','=',',','.','@' }; /** * 敏感词替换 * @param text 待替换文本 * @return 替换后的文本 */ public static String Filter(String text){ if(wordList == null || wordList.size() == 0) return text; char[] __char__ = text.toCharArray(); // 把String转化成char数组，便于遍历 int i,j; Word word; boolean flag; // 是否需要替换 for(i=0;i&lt;__char__.length;i++){ // 遍历所有字符 char c = __char__[i]; word = wordList.binaryGet(c); // 使用二分查找来寻找字符，提高效率 if(word != null){ // word != null说明找到了 flag = false; j = i+1; while (j &lt; __char__.length){ // 开始逐个比较后面的字符 if(skip(__char__[j])) { // 跳过空格之类的无关字符 j++; continue; } if(word.next != null){ // 字符串尚未结束，不确定是否存在敏感词 /* 以下代码并没有使用二分查找，因为以同一个字符开头的敏感词较少 例如，wordList中记录了所有敏感词的开头第一个字，它的数量通常会有上千个 假如现在锁定了字符“T”开头的敏感词，而“T”开头的敏感词只有10个，这时使用二分查找的效率反而低于顺序查找 */ word = word.next.get(__char__[j]); if(word == null){ break; } j++; }else { // 字符串已结束，存在敏感词汇 flag = true; break; } } if(word != null &amp;&amp; word.next == null){ flag = true; } if(flag){ // 如果flag==true，说明检测出敏感粗，需要替换 while (i&lt;j){ if(skip(__char__[i])){ // 跳过空格之类的无关字符，如果要把空格也替换成'*'，则删除这个if语句 i++; continue; } __char__[i] = replace; i++; } i--; } } } return new String(__char__); } /** * 加载敏感词列表 * @param words 敏感词数组 */ public static void loadWord(ArrayList&lt;String&gt; words){ if(words == null) return; char[] chars; List now; Word word; wordList = new List(); for(String __word__:words){ if(__word__ == null) continue; chars = __word__.toCharArray(); now = wordList; word = null; for(char c:chars){ if(word != null) { if(word.next == null) word.next = new List(); now = word.next; } word = now.get(c); if(word == null) word = now.add(c); } } sort(wordList); } /** * 加载敏感词txt文件，每个敏感词独占一行，不可出现空格，空行，逗号等非文字内容,必须使用UTF-8编码 * @param path txt文件的绝对地址 */ public static void loadWordFromFile(String path){ String encoding = \"UTF-8\"; File file = new File(path); try{ if(file.isFile() &amp;&amp; file.exists()){ InputStreamReader inputStreamReader = new InputStreamReader( new FileInputStream(file),encoding ); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((line = bufferedReader.readLine()) != null){ list.add(line); } bufferedReader.close(); inputStreamReader.close(); loadWord(list); } } catch (IOException e) { e.printStackTrace(); } } /** * 对敏感词多叉树递增排序 * @param list 待排序List */ private static void sort(List list){ if(list == null) return; Collections.sort(list); // 递增排序 for(Word word:list){ sort(word.next); } } /** * 判断是否跳过当前字符 * @param c 待检测字符 * @return true:需要跳过 false:不需要跳过 */ private static boolean skip(char c){ for(char c1:skip){ if(c1 == c) return true; } return false; } } 测试 public class Main { public static void main(String[] args) throws Exception{ SensitiveWordFilter.loadWordFromFile(\"D:/SensitiveWordList.txt\"); StringBuilder stringBuilder = new StringBuilder(); long t1,t2; for(int i=0;i&lt;100;i++){ stringBuilder.append(\"123TM,D123\"); } String s = stringBuilder.toString(); String result = null; t1 = System.nanoTime(); for(int i=0;i&lt;10000;i++){ result = SensitiveWordFilter.Filter(s); } t2 = System.nanoTime(); System.out.println(result); System.out.println((t2 - t1) / 1000000 + \"毫秒\"); } } 测试使用的敏感词库总共包含14596个敏感词(可能有个别重复),在测试代码里生成了一个长度为1000的字符串，总共包含100个相同敏感词，敏感词中间有逗号隔开重复执行过滤10000次，并打印结果和时间，结果如下 可以看到程序成功地过滤了敏感词，并保留了逗号，总耗时335毫秒，平均每次过滤仅需要0.03毫秒，并且是在上万个敏感词和超长字符串的情况下。 源文件+敏感词列表 在寻找敏感词列表时发现很多人的分享都被取消了，为了防止敏感词列表被检测出敏感词，使用了zip格式并加密。敏感词库存在部分重复，不过不影响使用。 密码:dearxuan 密码:dearxuan 密码:dearxuan 源代码+敏感词列表:https://dearx.lanzoui.com/iIh95ralmrc单独敏感词列表:https://dearx.lanzoui.com/iFQSrralmsd","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFA算法","slug":"DFA算法","permalink":"http://example.com/tags/DFA%E7%AE%97%E6%B3%95/"},{"name":"敏感词过滤","slug":"敏感词过滤","permalink":"http://example.com/tags/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"}],"author":"DearXuan"},{"title":"高斯模糊的Java实现及优化","slug":"高斯模糊的Java实现及优化","date":"2021-07-05T05:45:00.000Z","updated":"2021-08-20T07:21:55.551Z","comments":true,"path":"2021/07/05/高斯模糊的Java实现及优化/","link":"","permalink":"http://example.com/2021/07/05/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E7%9A%84Java%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"","text":"高斯模糊是被广泛使用的图形算法之一，在实现高斯模糊之前，先要了解正态分布 正态分布一维的正态分布为直接让f(x)和f(y)相乘，就得到了二维的正态分布此处直接令μ=0，将会在下面解释。 权值矩阵设有一个(2n+1)阶矩阵M，且有，我们称这个矩阵为权值矩阵，称为(i,j)点处的权。其中n是高斯模糊的半径。 离散卷积离散卷积是卷积对离散量的特殊形式，假设现有原图矩阵A,权值矩阵B,则点(x,y)处的离散卷积为在更严格的定义中，A(i,j)应该与B(u-i,v-j)相乘，但是针对本文的高斯模糊而言，其效果是一样的，且上面给出的公式更为简洁。 现在举个例子，有一张尺寸为3*3的图片S，将其颜色转化成矩阵A，为有权值矩阵B为将A(i,j)与B(i,j)相乘，将结果相加(-1) x 2 + (-1) x 4 + (-1) x 6 + (-1) x 8 + 5 x 5 = 5则以上两个矩阵的离散卷积结果为5，这就是矩阵A经过处理后得到的新矩阵M(2,2)的值。 在高斯模糊中，设模糊半径为n，则定义一个维数为2n+1的权值矩阵G，且G(i,j)=f(i-n-1,j-n-1)，类似于将一个直角坐标系放在了G的中点处，这就是μ=0的原因。此处的f是二维正态分布函数。然后求和，将矩阵的每个数除以这个和。求和的步骤是防止图片过亮或过暗。将得到的矩阵G代替B计算，其结果就是高斯模糊的结果 优化上述方法的效率较低，在介绍正态分布时，二维的正态分布函数是两个一维函数相乘得到的，这两个一维函数分别是f(x)和f(y)，f(x)代表水平方向，f(y)代表垂直方向。对于一个n维权值矩阵，用它来处理a*b尺寸的图片，如果用二维正态分布函数来计算，总共需要计算a*b*n*n=abn²次，及其繁琐。这时我们可以使用一维的正态分布函数，得出一个“权值列向量”，这个向量的作用类似权值矩阵，用这个列向量把图片横向处理，相当于f(x)，再用它把图片纵向处理，相当于f(y)，此时图片经过两次处理，相当于f(x)*f(y)，也可以达到二维正态分布的效果，而计算量仅仅是a*b*n+a*b*n=2abn，下降了一个数量级。该方法不详细介绍，将在代码中展示。 代码实现GaussianBlur类，算法的核心部分 public final class GaussianBlur { private static final int precision = 10000; // 精度，由于返回的是int数组，精度较低，因此需要将所有值同时扩大数倍，可以理解为把小数点向右移动 private static final double E = 2.718281828459045;//自然常数e private static final double PI = 3.141592653589793;//圆周率 /** * 快速高斯模糊 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] GaussianBlur(int[][][] picture,int radius){ int i, j, x, R, G, B, proportion, subscript; int[] matrix = LinearNormalDistribution(radius,1.5); int width = picture[0].length, height = picture[0][0].length; int[][][] color_1 = new int[3][width][height]; // 用来存高斯模糊后的数据 int[][][] color_2 = new int[3][width][height]; // 临时存储纵向滤波之后的数据 //纵向滤波 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; height) ? x : 2 * j - x; // 如果坐标越界了，则计算对称点来代替 R += picture[0][i][subscript] * proportion; G += picture[1][i][subscript] * proportion; B += picture[2][i][subscript] * proportion; } color_2[0][i][j] = R / precision; color_2[1][i][j] = G / precision; color_2[2][i][j] = B / precision; } } //横向滤波 for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * j - x; R += color_2[0][subscript][i] * proportion; G += color_2[1][subscript][i] * proportion; B += color_2[2][subscript][i] * proportion; } //注意for语句中i代表高度，j代表宽度，所以下面三个语句的i和j并没有写错位置 color_1[0][j][i] = R / precision; color_1[1][j][i] = G / precision; color_1[2][j][i] = B / precision; } } return color_1; } /** * 慢速高斯模糊，采用二维正态分布的方法来处理图像 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] SlowGaussianBlur(int[][][] picture,int radius){ //flag为真时计算加权，为假时直接代入矩阵 int[][] matrix = NormalDistribution(radius,1.5); int i, j, x, y, R, G, B, proportion, left, right, width = picture[0].length, height = picture[0][0].length; int[][][] color = new int[3][width][height]; //选取每个点 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { //选取半径为radius的矩阵 R = G = B = 0; for (x = i - radius; x &lt;= i + radius; x++) { for (y = j - radius; y &lt;= j + radius; y++) { //求出颜色 proportion = matrix[x + radius - i][y + radius - j]; left = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * i - x; right = (y &gt;= 0 &amp;&amp; y &lt; height) ? y : 2 * j - y; R += picture[0][left][right] * proportion; G += picture[1][left][right] * proportion; B += picture[2][left][right] * proportion; } } color[0][i][j] = R / precision; color[1][i][j] = G / precision; color[2][i][j] = B / precision; } } return color; } /** * 用一维正态分布函数来计算“权值列向量”，效率较高 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return “权值列向量” */ private static int[] LinearNormalDistribution(int radius,double SIGMA){ int[] matrix = new int[2 * radius + 1]; // 定义一个列向量 int sum, i; //计算各个点的正态分布值 sum = matrix[radius] = (int) (precision / (2 * PI * SIGMA * SIGMA)); // sum的初值为向量中心点的值，例如向量(1,2,3,2,1)，则初值为3 for (i = 1; i &lt;= radius; i++) { //根据对称性，可以减少一倍的运算量，i=0的情况已经在sum初值那一步考虑 matrix[radius-i] = matrix[radius+i] = (int) ((Math.pow(E, -i * i / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA)) * precision); sum += matrix[radius+i] * 2; // 计算向量所有值之和 } for (i = 0; i &lt; 2 * radius + 1; i++) { matrix[i] = matrix[i] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } return matrix; } /** * 用二维正态分布函数来计算权值矩阵，效率较低 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return 权值矩阵 */ private static int[][] NormalDistribution(int radius, double SIGMA) { int sum = 0, i, j; int[][] matrix = new int[2 * radius + 1][2 * radius + 1]; // 定义一个矩阵 //计算各个点的正态分布值 for (i = 0; i &lt;= radius; i++) { for (j = 0; j &lt;= radius; j++) { //写入矩阵并累加，根据矩阵的对称性可以减少3/4的运算量 matrix[radius-i][radius-j] = matrix[radius-i][radius+j] = matrix[radius+i][radius-j] = matrix[radius+i][radius+j] = (int) (Math.pow(E, -(i * i + j * j) / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA) * precision); sum += 4 * matrix[radius+i][radius+j]; } } //计算权值 for (i = 0; i &lt;= 2 * radius; i++) { for (j = 0; j &lt;= 2 * radius; j++) { matrix[i][j] = matrix[i][j] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } } return matrix; } } Filter类，通过调用GaussianBlur类来处理图像 import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; public final class Filter { public static BufferedImage GaussianBlur(String path){ int pixel; try { BufferedImage image = ImageIO.read(new File(path)); int width = image.getWidth(),height = image.getHeight(); int[][][] picture = new int[3][width][height]; for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = image.getRGB(i,j); //获取每个点的RGB值 picture[0][i][j] = (pixel &amp; 0xff0000) &gt;&gt; 16; picture[1][i][j] = (pixel &amp; 0xff00) &gt;&gt; 8; picture[2][i][j] = (pixel &amp; 0xff); } } picture = GaussianBlur.GaussianBlur(picture,100); // 快速高斯模糊 for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = ((picture[0][i][j] &amp; 0xff) &lt;&lt; 16) + ((picture[1][i][j] &amp; 0xff) &lt;&lt; 8) + (picture[2][i][j] &amp; 0xff); image.setRGB(i,j,pixel); } } return image; } catch (IOException e) { e.printStackTrace(); return null; } } } Main,打开1.jpg并高斯模糊，保存为2.jpg import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; public class Main { public static void main(String[] args) throws Exception{ BufferedImage image = Filter.GaussianBlur(\"D://1.jpg\"); ImageIO.write(image,\"jpg\",new File(\"D://2.jpg\")); } } 效果原图 高斯模糊之后的图(半径20，SIGMA1.5)源文件https://dearx.lanzoui.com/iSxBJr0uu6d","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"图形算法","slug":"图形算法","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%97%E6%B3%95/"}],"author":"DearXuan"}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"C#","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/categories/Wallpaper/"},{"name":"Qt","slug":"Wallpaper/Qt","permalink":"http://example.com/categories/Wallpaper/Qt/"},{"name":"C#","slug":"Wallpaper/C","permalink":"http://example.com/categories/Wallpaper/C/"},{"name":"exe项目","slug":"C/exe项目","permalink":"http://example.com/categories/C/exe%E9%A1%B9%E7%9B%AE/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Dll","slug":"Dll","permalink":"http://example.com/tags/Dll/"},{"name":"GPU编程","slug":"GPU编程","permalink":"http://example.com/tags/GPU%E7%BC%96%E7%A8%8B/"},{"name":"硬件加速","slug":"硬件加速","permalink":"http://example.com/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"},{"name":"Wallpaper","slug":"Wallpaper","permalink":"http://example.com/tags/Wallpaper/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"反作弊","slug":"反作弊","permalink":"http://example.com/tags/%E5%8F%8D%E4%BD%9C%E5%BC%8A/"},{"name":"逆向分析","slug":"逆向分析","permalink":"http://example.com/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"内存读写","slug":"内存读写","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/"},{"name":"序列化对象","slug":"序列化对象","permalink":"http://example.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1/"},{"name":"二进制","slug":"二进制","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"底层原理","slug":"底层原理","permalink":"http://example.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"RSA加密","slug":"RSA加密","permalink":"http://example.com/tags/RSA%E5%8A%A0%E5%AF%86/"},{"name":"离线验证","slug":"离线验证","permalink":"http://example.com/tags/%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"DFA算法","slug":"DFA算法","permalink":"http://example.com/tags/DFA%E7%AE%97%E6%B3%95/"},{"name":"敏感词过滤","slug":"敏感词过滤","permalink":"http://example.com/tags/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"图形算法","slug":"图形算法","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%97%E6%B3%95/"}]}