{"meta":{"title":"DearXuan的主页","subtitle":"","description":"欢迎访问DearXuan的主页!","author":"DearXuan","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-08-19T13:41:53.000Z","updated":"2021-08-19T13:41:53.448Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-19T13:40:38.000Z","updated":"2021-08-19T13:40:38.593Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-19T13:41:45.000Z","updated":"2021-08-19T13:41:45.971Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用RSA加密实现的简易离线验证功能(C#,含代码)","slug":"用RSA加密实现的简易离线验证功能","date":"2021-08-20T02:44:58.000Z","updated":"2021-08-20T02:51:48.577Z","comments":true,"path":"2021/08/20/用RSA加密实现的简易离线验证功能/","link":"","permalink":"http://example.com/2021/08/20/%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"许多软件都有正版验证功能，它们通常需要联网验证，验证的本质则是加密与解密，本文将使用RSA加密算法实现简易的离线验证功能 RSA加密设p,q是两个超级大的素数，N=pq，数据通过欧拉函数φ(N)来加密，而欧拉函数φ(N)满足φ(N)= φ(pq)=(p-1)(q-1)，如果要算出φ(N)，就必须知道p和q。并且这有一点好处，某人可以公开宣布他的密钥e以及N，任何人都可以给他发送密文，但是只有他能看懂。因为想要破解密码，就必须知道那两个超级大素数p,q.p和q的位数决定了密文的安全性。 硬件绑定由于是离线验证，所以我们能很容易想到可以根据电脑的硬件信息生成一串加密字符串，程序根据加密字符串解密出硬件信息，如果解密出来的信息与实际电脑配置信息相同，则认为验证通过。同时我们还可以在字符串上添加一些额外信息，例如有效期，这样就能做到限定时间的功能。这里以BIOS为例，使用ManagementClass和ManagementObjectCollection读取硬件信息，注意这两个类的命名空间为System.Management 123456789101112131415161718192021ManagementClass mc = null;ManagementObjectCollection moc = null;try{ mc = new ManagementClass(\"Win32_BIOS\"); moc = mc.GetInstances(); foreach (ManagementObject mo in moc) { bios = mo.Properties[\"SerialNumber\"].Value.ToString(); break; }}catch(Exception ex){ bios = null;}finally{ if (mc != null) mc.Dispose(); if (moc != null) moc.Dispose();} 程序读取了BIOS编号，并保存在bios字符串中现在根据BIOS编号生成密文，C#提供了RSACryptoServiceProvider来帮助加密，注意这个类的命名空间为System.Security.Cryptography 12345678910111213141516171819public static string Encrypt(string content){ string publickey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(publickey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false); return Convert.ToBase64String(cipherbytes);} public static string Decrypt(string content){ string privatekey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/hf2dnK7rNfl3lbqghWcpFdu778hUpIEBixCDL5WiBtpkZdpSw90aERmHJYaW2RGvGRi6zSftLh00KHsPcNUMw==&lt;/P&gt;&lt;Q&gt;6Cn/jOLrPapDTEp1Fkq+uz++1Do0eeX7HYqi9rY29CqShzCeI7LEYOoSwYuAJ3xA/DuCdQENPSoJ9KFbO4Wsow==&lt;/Q&gt;&lt;DP&gt;ga1rHIJro8e/yhxjrKYo/nqc5ICQGhrpMNlPkD9n3CjZVPOISkWF7FzUHEzDANeJfkZhcZa21z24aG3rKo5Qnw==&lt;/DP&gt;&lt;DQ&gt;MNGsCB8rYlMsRZ2ek2pyQwO7h/sZT8y5ilO9wu08Dwnot/7UMiOEQfDWstY3w5XQQHnvC9WFyCfP4h4QBissyw==&lt;/DQ&gt;&lt;InverseQ&gt;EG02S7SADhH1EVT9DD0Z62Y0uY7gIYvxX/uq+IzKSCwB8M2G7Qv9xgZQaQlLpCaeKbux3Y59hHM+KpamGL19Kg==&lt;/InverseQ&gt;&lt;D&gt;vmaYHEbPAgOJvaEXQl+t8DQKFT1fudEysTy31LTyXjGu6XiltXXHUuZaa2IPyHgBz0Nd7znwsW/S44iql0Fen1kzKioEL3svANui63O3o5xdDeExVM6zOf1wUUh/oldovPweChyoAdMtUzgvCbJk1sYDJf++Nr0FeNW1RB1XG30=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privatekey); cipherbytes = rsa.Decrypt(Convert.FromBase64String(content), false); return Encoding.UTF8.GetString(cipherbytes);} 两部分核心代码已经完成，在程序中先获取BIOS编号，然后提示用户输入许可证，这个许可证实际上就是密文，程序解密密文，这里需要注意的是，如果用户输入的密文格式有误，则解密函数会抛出异常，因此需要套上try来执行，如果发生异常，则一律认为验证失败。以下是程序界面 文件读写验证模块已经完成，但是每次打开都要用户手动输入许可证，及其繁琐，因此我们需要将许可证保存在本地。首先在D盘创建ducuments目录，在document里创建LICENSE文件，注意需引入命名空间System.IO定义地址 123private static string dirname = @\"D:\\documents\";private static string filename = \"LICENSE.dx\";private static string path = System.IO.Path.Combine(dirname, filename); 创建目录和文件，这里需注意Create后必须dispose，否则接下来读取时会提示被占用 123456System.IO.Directory.CreateDirectory(dirname);if (!File.Exists(path)){ FileStream fileStream = System.IO.File.Create(path); fileStream.Dispose();} 读取和写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static string ReadFile(){ string key = \"\"; string line; StreamReader sr = null; try { sr = new StreamReader(path); while ((line = sr.ReadLine()) != null) { key += line; } } catch(Exception ex) { key = null; } finally { if(sr != null) { sr.Dispose(); } } return key;} public static void WriteFile(string key){ StreamWriter sw = null; try { sw = new StreamWriter(path); sw.Write(key); } catch (Exception ex) { } finally { if (sw != null) { sw.Dispose(); } }} StreamReader和StreamWriter可以放在using里面执行，这样就会自动销毁，但是为了显示dispose的重要性，本程序中手动disposeStreamReader将许可证以文本形式写入文件里，而读取也是文本形式读取，所以文件的后缀名可以随便取。","categories":[],"tags":[],"author":"DearXuan"},{"title":"C#实现简易XML阅读器(含源文件和exe文件)","slug":"C-实现简易XML阅读器","date":"2021-07-14T13:01:00.000Z","updated":"2021-08-20T02:59:27.540Z","comments":true,"path":"2021/07/14/C-实现简易XML阅读器/","link":"","permalink":"http://example.com/2021/07/14/C-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93XML%E9%98%85%E8%AF%BB%E5%99%A8/","excerpt":"","text":"功能本程序的主要目的是便于阅读XML文件。在网上复制一些XML文本时，常常出现格式错误，更有甚者，整个文本就一行，一行有几百个字符。这些奇奇怪怪的格式大大增加了理解难度，本程序将模仿记事本，提供基础的文件读写，编辑功能，并在此基础上增加了格式对齐和高亮功能。 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;Class&gt; &lt;Student&gt; &lt;ID&gt;1111&lt;/ID&gt; &lt;name&gt;Happy&lt;/name&gt; &lt;/Student&gt; &lt;Student&gt; &lt;ID&gt;2222&lt;/ID&gt; &lt;name&gt;Sad&lt;/name&gt; &lt;/Student&gt; &lt;/Class&gt; 界面设计主界面分为菜单栏和输入框 文件读写新建FileIO.cs，引入命名空间System.IO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static class FileIO{ public static string ReadFile(string path) { if (path == null) return null; string line; string s = \"\"; StreamReader streamReader = null; try { streamReader = new StreamReader(path); while((line = streamReader.ReadLine()) != null) { s += line + \"\\n\"; } } catch(Exception ex) { s = null; } finally { if (streamReader != null) streamReader.Dispose(); } return s; } public static bool WriteFile(string path,string content) { StreamWriter streamWriter = null; try { streamWriter = new StreamWriter(path); streamWriter.Write(content); } catch(Exception ex) { return false; } finally { if (streamWriter != null) streamWriter.Dispose(); } return true; }} ReadFile函数根据传入的地址，读取文件内容，WriteFile则负责保存文件，返回的布尔值用于判断是否保存成功。有人可能会对WriteFile里的catch产生疑惑，在catch里直接return了，那finally的代码不就无法执行了吗？实际上在执行return之前，会先把要return的数据保存，然后执行finally里的语句，最后再return刚刚保存的参数。例如我在catch里return a，而a=1，即使我在finally里把a赋值成2，那最后返回的仍然是1. 查找和替换DFA算法可以极大提高长字符串的查找效率 123456789101112131415161718192021222324252627282930313233343536373839404142public bool textHasChanged = true;public bool wordHasChanged = true;private char[] word;private char[] text;private bool GetWord(){ if(main.richTextBox1.Text.Length == 0) { MessageBox.Show(\"文本内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if(textBox1.Text.Length == 0) { MessageBox.Show(\"查找内容为空!\", \"错误\", MessageBoxButtons.OK, MessageBoxIcon.Error); return false; } if (textHasChanged) { if (checkBox1.Checked)//不区分大小写 { text = main.richTextBox1.Text.ToLower().ToCharArray(); } else { text = main.richTextBox1.Text.ToCharArray(); } textHasChanged = false; } if (wordHasChanged) { if (checkBox1.Checked)//不区分大小写 { word = textBox1.Text.ToLower().ToCharArray(); } else { word = textBox1.Text.ToCharArray(); } wordHasChanged = false; } return true;} 首先定义char数组word和text，分别表示需要查找的内容和全部文本，使用ToCharArray()将string转化成char数组，在实际使用中，常常会连续使用多次查找功能，如果每次查找时都要转换以下，会增大系统开销，因此需要设定布尔变量来表示字符串内容是否被修改，仅当用户手动修改了word或者text内容时才重新转换。其中“查找”按钮就是简单的统计字符串在文本中出现了多少次，并选中第一次出现的位置，实现较为容易，不展示源码。“上一处”和“下一处”则要根据鼠标光标的位置寻找上一个或下一个出现的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243private void button2_Click(object sender, EventArgs e)//向下查找{ if (!GetWord()) return; int i, j; bool flag; if (checkBox1.Checked) { flag = main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower()); } else { flag = main.richTextBox1.SelectedText.Equals(textBox1.Text); } if (flag) { i = main.richTextBox1.SelectionStart + main.richTextBox1.SelectionLength; } else { i = main.richTextBox1.SelectionStart; } if (i == text.Length) i = 0; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &lt; text.Length &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i + j &lt; text.Length &amp;&amp; text[i + j] == word[j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i, j); main.Focus(); return; } } i += j + 1; alreadySearchLength += j + 1; if (i &gt;= text.Length &amp;&amp; checkBox2.Checked) i = 0; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None);} 查找之前使用Getword()来获取最新的char数组，此时还要考虑一种情况，假设用户需要查找”abc”，并且用户当前已经选中”abc”，就需要将起始位置设置为光标位置的后3格。同时如果用户勾选了”循环”，则变量 i 超出文本长度时，需要将它设置为0，但是这又会引起另一个问题：死循环。为了防止出现死循环，可以设置一个变量alreadySearchLength，这个变量记录已经查找过的字符串长度，当这个变量超过文本长度时，说明已经遍历了全部字符，则退出循环。查找采用了DFA算法，将需要查找的字符串的首字符跟text数组比较，遇到相同的再比较下一个，这样可以减少查找所用时间。向下查找和向上查找代码大致相同，但是向上查找不需要判断当前选中字符串是否就是需要查找的字符串。 123456789101112131415161718192021222324252627private void button3_Click(object sender, EventArgs e)//向上查找{ if (!GetWord()) return; int i = main.richTextBox1.SelectionStart,j; if (i == 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; if (i == text.Length) i = text.Length - 1; int maxSearchLength = text.Length; int alreadySearchLength = 0; while (i &gt;= 0 &amp;&amp; alreadySearchLength &lt;= maxSearchLength) { j = 0; while (i - j &gt;= 0 &amp;&amp; text[i - j] == word[word.Length - 1 - j]) { j++; if (j == word.Length) { main.richTextBox1.Select(i - j + 1, j); main.Focus(); return; } } i -= j + 1; alreadySearchLength += j + 1; if (i &lt;= 0 &amp;&amp; checkBox2.Checked) i = text.Length - 1; } MessageBox.Show(\"未找到!\", \"查找结果\", MessageBoxButtons.OK, MessageBoxIcon.None);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void button1_Click(object sender, EventArgs e)//替换{ if (checkBox1.Checked) { if (main.richTextBox1.SelectedText.ToLower().Equals(textBox1.Text.ToLower())) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if(start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if(start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } } else { if (main.richTextBox1.SelectedText.Equals(textBox1.Text)) { int position = main.richTextBox1.SelectionStart + textBox2.Text.Length; ReplaceWord(main.richTextBox1.SelectionStart, main.richTextBox1.SelectionLength); main.richTextBox1.Select(position, 0); int start = SearchNext(); if (start &gt;= 0) { main.richTextBox1.Select(start, textBox1.Text.Length); } main.Focus(); } else { int start = SearchNext(); if (start &lt; 0) { ShowNotFoundDialog(); } else { main.richTextBox1.Select(start, textBox1.Text.Length); main.Focus(); } } }} 替换比起查找较为复杂，首先是判断当前选中字符串是否就是要替换的内容，如果是，替换当前选中的文本，并选中下一个出现的位置；如果不是，直接选中下一个出现的位置。替换是利用字符串截取功能实现的，因此在替换前需要先保存光标位置，替换后再重设光标位置。 对齐与高亮对齐可以使用C#自带的XmlTextWriter来实现，注意命名空间为System.Xml高亮比之前的查找和替换简单，只需要根据尖括号来查找就行，并将尖括号里的内容设置为蓝色 1234567891011121314151617181920212223242526if (richTextBox1.Text.Trim().Equals(\"\")){ MessageBox.Show(\"内容为空.\", \"对齐\"); return;}try{ XmlDocument document = new XmlDocument(); document.LoadXml(richTextBox1.Text); MemoryStream memoryStream = new MemoryStream(); XmlTextWriter writer = new XmlTextWriter(memoryStream, null) { Formatting = Formatting.Indented }; document.Save(writer); StreamReader streamReader = new StreamReader(memoryStream); memoryStream.Position = 0; string xmlString = streamReader.ReadToEnd(); streamReader.Close(); memoryStream.Close(); richTextBox1.Text = xmlString;}catch(Exception ex){ MessageBox.Show(ex.Message);} 启动参数为了实现快捷打开文本文件，需要程序读取启动参数并在启动后立即打开参数指定的文件 12345678910111213141516171819202122232425262728293031public Form1(string[] args){ InitializeComponent(); if(args.Length != 0) { filePath = args[0]; if (!filePath.EndsWith(\".txt\")) { switch(MessageBox.Show(\"XML Reader仅支持文本文件，是否以文本形式打开\" + filePath + \"?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None)) { case DialogResult.OK: break; case DialogResult.No: filePath = null; return; case DialogResult.Cancel: System.Environment.Exit(0); break; } } string content = FileIO.ReadFile(filePath); if (content == null) { filePath = null; } else { LoadXML(content); } }} 注意string[] args并不是自动生成的，而是我手动加上去的，首先在程序入口点Program.Main里获取args，然后再传递给主窗体 12345678910111213static class Program{ /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main(string[] args) { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1(args)); }} 拖拽事件当用户手动拖入某个文件时，快捷打开该文件事件窗口里并没有为我们提供拖拽事件，因此我们需要自己手动定义一个 12richTextBox1.AllowDrop = true;richTextBox1.DragDrop += new DragEventHandler(richTextBox1_DragDrop); 改写DragDrop函数 12345678910111213141516171819202122232425262728293031323334353637private void richTextBox1_DragDrop(object sender, DragEventArgs e){ string[] files = (string[])e.Data.GetData(DataFormats.FileDrop); if (files.Length == 0) return; string file = files[0]; if (Path.GetExtension(file).Equals(\".txt\")) { string s = FileIO.ReadFile(file); if(s == null) { MessageBox.Show(\"读取失败.\", \"XML Reader\", MessageBoxButtons.OK, MessageBoxIcon.Information); return; } else { if (!isSaved) { DialogResult result = MessageBox.Show(\"你想将更改保存到\" + Text + \"吗?\", \"XML Reader\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.None); switch (result) { case DialogResult.OK: 保存ToolStripMenuItem_Click(null, null); break; case DialogResult.No: break; case DialogResult.Cancel: return; } } LoadXML(s); } } else { MessageBox.Show(\"该类型的文件不被支持.\", \"XML Reader\"); }} 最终成果 源文件EXE程序:https://dearx.lanzoui.com/ioNRKrez29c源文件:https://dearx.lanzoui.com/i7bWzrez2fi","categories":[{"name":"XML","slug":"XML","permalink":"http://example.com/categories/XML/"},{"name":"启动参数","slug":"XML/启动参数","permalink":"http://example.com/categories/XML/%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"利用RSA加密实现的简易离线验证功能(C#,含代码)","slug":"利用RSA加密实现的简易离线验证功能","date":"2021-07-13T14:02:00.000Z","updated":"2021-08-20T02:51:21.388Z","comments":true,"path":"2021/07/13/利用RSA加密实现的简易离线验证功能/","link":"","permalink":"http://example.com/2021/07/13/%E5%88%A9%E7%94%A8RSA%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E6%98%93%E7%A6%BB%E7%BA%BF%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"许多软件都有正版验证功能，它们通常需要联网验证，验证的本质则是加密与解密，本文将使用RSA加密算法实现简易的离线验证功能 RSA加密设p,q是两个超级大的素数，N=pq，数据通过欧拉函数φ(N)来加密，而欧拉函数φ(N)满足φ(N)= φ(pq)=(p-1)(q-1)，如果要算出φ(N)，就必须知道p和q。并且这有一点好处，某人可以公开宣布他的密钥e以及N，任何人都可以给他发送密文，但是只有他能看懂。因为想要破解密码，就必须知道那两个超级大素数p,q.p和q的位数决定了密文的安全性。 硬件绑定由于是离线验证，所以我们能很容易想到可以根据电脑的硬件信息生成一串加密字符串，程序根据加密字符串解密出硬件信息，如果解密出来的信息与实际电脑配置信息相同，则认为验证通过。同时我们还可以在字符串上添加一些额外信息，例如有效期，这样就能做到限定时间的功能。这里以BIOS为例，使用ManagementClass和ManagementObjectCollection读取硬件信息，注意这两个类的命名空间为System.Management 123456789101112131415161718192021ManagementClass mc = null;ManagementObjectCollection moc = null;try{ mc = new ManagementClass(\"Win32_BIOS\"); moc = mc.GetInstances(); foreach (ManagementObject mo in moc) { bios = mo.Properties[\"SerialNumber\"].Value.ToString(); break; }}catch(Exception ex){ bios = null;}finally{ if (mc != null) mc.Dispose(); if (moc != null) moc.Dispose();} 程序读取了BIOS编号，并保存在bios字符串中现在根据BIOS编号生成密文，C#提供了RSACryptoServiceProvider来帮助加密，注意这个类的命名空间为System.Security.Cryptography 12345678910111213141516171819public static string Encrypt(string content){ string publickey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(publickey); cipherbytes = rsa.Encrypt(Encoding.UTF8.GetBytes(content), false); return Convert.ToBase64String(cipherbytes);} public static string Decrypt(string content){ string privatekey = @\"&lt;RSAKeyValue&gt;&lt;Modulus&gt;5m9m14XH3oqLJ8bNGw9e4rGpXpcktv9MSkHSVFVMjHbfv+SJ5v0ubqQxa5YjLN4vc49z7SVju8s0X4gZ6AzZTn06jzWOgyPRV54Q4I0DCYadWW4Ze3e+BOtwgVU1Og3qHKn8vygoj40J6U85Z/PTJu3hN1m75Zr195ju7g9v4Hk=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;/hf2dnK7rNfl3lbqghWcpFdu778hUpIEBixCDL5WiBtpkZdpSw90aERmHJYaW2RGvGRi6zSftLh00KHsPcNUMw==&lt;/P&gt;&lt;Q&gt;6Cn/jOLrPapDTEp1Fkq+uz++1Do0eeX7HYqi9rY29CqShzCeI7LEYOoSwYuAJ3xA/DuCdQENPSoJ9KFbO4Wsow==&lt;/Q&gt;&lt;DP&gt;ga1rHIJro8e/yhxjrKYo/nqc5ICQGhrpMNlPkD9n3CjZVPOISkWF7FzUHEzDANeJfkZhcZa21z24aG3rKo5Qnw==&lt;/DP&gt;&lt;DQ&gt;MNGsCB8rYlMsRZ2ek2pyQwO7h/sZT8y5ilO9wu08Dwnot/7UMiOEQfDWstY3w5XQQHnvC9WFyCfP4h4QBissyw==&lt;/DQ&gt;&lt;InverseQ&gt;EG02S7SADhH1EVT9DD0Z62Y0uY7gIYvxX/uq+IzKSCwB8M2G7Qv9xgZQaQlLpCaeKbux3Y59hHM+KpamGL19Kg==&lt;/InverseQ&gt;&lt;D&gt;vmaYHEbPAgOJvaEXQl+t8DQKFT1fudEysTy31LTyXjGu6XiltXXHUuZaa2IPyHgBz0Nd7znwsW/S44iql0Fen1kzKioEL3svANui63O3o5xdDeExVM6zOf1wUUh/oldovPweChyoAdMtUzgvCbJk1sYDJf++Nr0FeNW1RB1XG30=&lt;/D&gt;&lt;/RSAKeyValue&gt;\"; RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(); byte[] cipherbytes; rsa.FromXmlString(privatekey); cipherbytes = rsa.Decrypt(Convert.FromBase64String(content), false); return Encoding.UTF8.GetString(cipherbytes);} 两部分核心代码已经完成，在程序中先获取BIOS编号，然后提示用户输入许可证，这个许可证实际上就是密文，程序解密密文，这里需要注意的是，如果用户输入的密文格式有误，则解密函数会抛出异常，因此需要套上try来执行，如果发生异常，则一律认为验证失败。以下是程序界面 文件读写验证模块已经完成，但是每次打开都要用户手动输入许可证，及其繁琐，因此我们需要将许可证保存在本地。首先在D盘创建ducuments目录，在document里创建LICENSE文件，注意需引入命名空间System.IO定义地址 123private static string dirname = @\"D:\\documents\";private static string filename = \"LICENSE.dx\";private static string path = System.IO.Path.Combine(dirname, filename); 创建目录和文件，这里需注意Create后必须dispose，否则接下来读取时会提示被占用 123456System.IO.Directory.CreateDirectory(dirname);if (!File.Exists(path)){ FileStream fileStream = System.IO.File.Create(path); fileStream.Dispose();} 读取和写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static string ReadFile(){ string key = \"\"; string line; StreamReader sr = null; try { sr = new StreamReader(path); while ((line = sr.ReadLine()) != null) { key += line; } } catch(Exception ex) { key = null; } finally { if(sr != null) { sr.Dispose(); } } return key;} public static void WriteFile(string key){ StreamWriter sw = null; try { sw = new StreamWriter(path); sw.Write(key); } catch (Exception ex) { } finally { if (sw != null) { sw.Dispose(); } }} StreamReader和StreamWriter可以放在using里面执行，这样就会自动销毁，但是为了显示dispose的重要性，本程序中手动disposeStreamReader将许可证以文本形式写入文件里，而读取也是文本形式读取，所以文件的后缀名可以随便取。","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"加密","slug":"算法/加密","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/"},{"name":"RSA","slug":"算法/加密/RSA","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/"},{"name":"硬件绑定","slug":"算法/加密/RSA/硬件绑定","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"name":"文件读写","slug":"算法/加密/RSA/硬件绑定/文件读写","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"DearXuan"},{"title":"DFA算法-简易Java敏感词过滤(含源文件和上万敏感词列表)","slug":"DFA算法-简易Java敏感词过滤","date":"2021-07-11T14:39:00.000Z","updated":"2021-08-20T02:50:59.278Z","comments":true,"path":"2021/07/11/DFA算法-简易Java敏感词过滤/","link":"","permalink":"http://example.com/2021/07/11/DFA%E7%AE%97%E6%B3%95-%E7%AE%80%E6%98%93Java%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/","excerpt":"","text":"敏感词过滤说白了就是简单的字符串替换，Java本身已经提供了相关函数，但是一旦遇到长文本，或者敏感词数量庞大，效率下降就会非常明显。本文将介绍利用多叉树进行敏感词存储和过滤的方法。 多叉树多叉树是一种特殊的数据结构，如下图Head为头节点，下面的ABCDE均为子树。那么多叉树是如何存储敏感词的呢？首先将敏感词分解为一个一个的字符，例如敏感词”CSDN”，第一个字符是C，则在Head下创建子树”C”(如果已经存在则跳过这一步)。第二个字符是S，则在子树”C”下面创建”S”接下来是D，N，创建完N就可以结束了。如此循环，就可以创建出类似上图的多叉树。检测敏感词时，对于字符串中的每一个字符，先查找Head下是否有存在对应子树，例如字符串”ELN”，先读取第一个字符E，并检查Head，发现存在子树”E”；于是读取第二个字符L，并检查子树E的子树，发现存在L；最后读取第三个字符N，发现子树N还是存在。此时发现子树N后面没有内容，这说明ELN是一个敏感词，于是将ELN替换成”***“。这种算法会出现一个小意外，如果一个敏感词恰好是另一个敏感词的前缀，就会导致较短的敏感词被长的敏感词覆盖，这种情况可以通过添加结束标记来区分。不过我的想法是，如果出现这种情况，直接把前缀屏蔽掉就行了，这样后半段也不算敏感词了(好像实际工作中不能这样做)，因此我没有添加结束标记。 代码首先要先写一个数据结构来模拟多叉树，下图里Word就是一颗树，里面保存着当前字符c和子树next，compareTo是用来排序的，以提高查找效率。 12345678910111213public class Word implements Comparable&lt;Word&gt;{ public char c; public List next = null; public Word(char c){ this.c = c; } @Override public int compareTo(Word word) { return c - word.c; }} 上图的List继承了ArrayList，主要是因为ArrayList可以动态添加元素，便于偷懒 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList; public class List extends ArrayList&lt;Word&gt; { public Word get(char c){ for(Word w :this){ if(w.c == c) return w; } return null; } /** * 二分查找，必须先升序排序 * @param c 需要查找的字符 * @return Word对象：如果找到 null:如果没找到 */ public Word binaryGet(char c){ int left,right,key; Word word; left = 0;right = this.size()-1; while (left &lt;= right){ key = (left + right) / 2; word = get(key); if(word.c == c){ return word; }else if(word.c &gt; c){ right = key - 1; }else { left = key + 1; } } return null; } public Word add(char c){ Word word = new Word(c); super.add(word); return word; }} 以下是核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import java.io.*;import java.util.ArrayList;import java.util.Collections; public final class SensitiveWordFilter { public static List wordList; private final static char replace = '*'; // 替代字符 private final static char[] skip = new char[]{ // 遇到这些字符就会跳过，例如,如果\"AB\"是敏感词，那么\"A B\",\"A=B\"也会被屏蔽 '!','*','-','+','_','=',',','.','@' }; /** * 敏感词替换 * @param text 待替换文本 * @return 替换后的文本 */ public static String Filter(String text){ if(wordList == null || wordList.size() == 0) return text; char[] __char__ = text.toCharArray(); // 把String转化成char数组，便于遍历 int i,j; Word word; boolean flag; // 是否需要替换 for(i=0;i&lt;__char__.length;i++){ // 遍历所有字符 char c = __char__[i]; word = wordList.binaryGet(c); // 使用二分查找来寻找字符，提高效率 if(word != null){ // word != null说明找到了 flag = false; j = i+1; while (j &lt; __char__.length){ // 开始逐个比较后面的字符 if(skip(__char__[j])) { // 跳过空格之类的无关字符 j++; continue; } if(word.next != null){ // 字符串尚未结束，不确定是否存在敏感词 /* 以下代码并没有使用二分查找，因为以同一个字符开头的敏感词较少 例如，wordList中记录了所有敏感词的开头第一个字，它的数量通常会有上千个 假如现在锁定了字符“T”开头的敏感词，而“T”开头的敏感词只有10个，这时使用二分查找的效率反而低于顺序查找 */ word = word.next.get(__char__[j]); if(word == null){ break; } j++; }else { // 字符串已结束，存在敏感词汇 flag = true; break; } } if(word != null &amp;&amp; word.next == null){ flag = true; } if(flag){ // 如果flag==true，说明检测出敏感粗，需要替换 while (i&lt;j){ if(skip(__char__[i])){ // 跳过空格之类的无关字符，如果要把空格也替换成'*'，则删除这个if语句 i++; continue; } __char__[i] = replace; i++; } i--; } } } return new String(__char__); } /** * 加载敏感词列表 * @param words 敏感词数组 */ public static void loadWord(ArrayList&lt;String&gt; words){ if(words == null) return; char[] chars; List now; Word word; wordList = new List(); for(String __word__:words){ if(__word__ == null) continue; chars = __word__.toCharArray(); now = wordList; word = null; for(char c:chars){ if(word != null) { if(word.next == null) word.next = new List(); now = word.next; } word = now.get(c); if(word == null) word = now.add(c); } } sort(wordList); } /** * 加载敏感词txt文件，每个敏感词独占一行，不可出现空格，空行，逗号等非文字内容,必须使用UTF-8编码 * @param path txt文件的绝对地址 */ public static void loadWordFromFile(String path){ String encoding = \"UTF-8\"; File file = new File(path); try{ if(file.isFile() &amp;&amp; file.exists()){ InputStreamReader inputStreamReader = new InputStreamReader( new FileInputStream(file),encoding ); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((line = bufferedReader.readLine()) != null){ list.add(line); } bufferedReader.close(); inputStreamReader.close(); loadWord(list); } } catch (IOException e) { e.printStackTrace(); } } /** * 对敏感词多叉树递增排序 * @param list 待排序List */ private static void sort(List list){ if(list == null) return; Collections.sort(list); // 递增排序 for(Word word:list){ sort(word.next); } } /** * 判断是否跳过当前字符 * @param c 待检测字符 * @return true:需要跳过 false:不需要跳过 */ private static boolean skip(char c){ for(char c1:skip){ if(c1 == c) return true; } return false; }} 测试 12345678910111213141516171819public class Main { public static void main(String[] args) throws Exception{ SensitiveWordFilter.loadWordFromFile(\"D:/SensitiveWordList.txt\"); StringBuilder stringBuilder = new StringBuilder(); long t1,t2; for(int i=0;i&lt;100;i++){ stringBuilder.append(\"123TM,D123\"); } String s = stringBuilder.toString(); String result = null; t1 = System.nanoTime(); for(int i=0;i&lt;10000;i++){ result = SensitiveWordFilter.Filter(s); } t2 = System.nanoTime(); System.out.println(result); System.out.println((t2 - t1) / 1000000 + \"毫秒\"); }} 测试使用的敏感词库总共包含14596个敏感词(可能有个别重复),在测试代码里生成了一个长度为1000的字符串，总共包含100个相同敏感词，敏感词中间有逗号隔开重复执行过滤10000次，并打印结果和时间，结果如下 可以看到程序成功地过滤了敏感词，并保留了逗号，总耗时335毫秒，平均每次过滤仅需要0.03毫秒，并且是在上万个敏感词和超长字符串的情况下。 源文件+敏感词列表 在寻找敏感词列表时发现很多人的分享都被取消了，为了防止敏感词列表被检测出敏感词，使用了zip格式并加密。敏感词库存在部分重复，不过不影响使用。 密码:dearxuan 密码:dearxuan 密码:dearxuan 源代码+敏感词列表:https://dearx.lanzoui.com/iIh95ralmrc单独敏感词列表:https://dearx.lanzoui.com/iFQSrralmsd","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"敏感词过滤","slug":"算法/敏感词过滤","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"多叉树","slug":"算法/敏感词过滤/多叉树","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"DearXuan"},{"title":"高斯模糊的Java实现及优化","slug":"高斯模糊的Java实现及优化","date":"2021-07-05T05:45:00.000Z","updated":"2021-08-20T02:36:37.913Z","comments":true,"path":"2021/07/05/高斯模糊的Java实现及优化/","link":"","permalink":"http://example.com/2021/07/05/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E7%9A%84Java%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"","text":"高斯模糊是被广泛使用的图形算法之一，在实现高斯模糊之前，先要了解正态分布 正态分布一维的正态分布为直接让f(x)和f(y)相乘，就得到了二维的正态分布此处直接令μ=0，将会在下面解释。 权值矩阵设有一个(2n+1)阶矩阵M，且有，我们称这个矩阵为权值矩阵，称为(i,j)点处的权。其中n是高斯模糊的半径。 离散卷积离散卷积是卷积对离散量的特殊形式，假设现有原图矩阵A,权值矩阵B,则点(x,y)处的离散卷积为在更严格的定义中，A(i,j)应该与B(u-i,v-j)相乘，但是针对本文的高斯模糊而言，其效果是一样的，且上面给出的公式更为简洁。 现在举个例子，有一张尺寸为3*3的图片S，将其颜色转化成矩阵A，为有权值矩阵B为将A(i,j)与B(i,j)相乘，将结果相加(-1) x 2 + (-1) x 4 + (-1) x 6 + (-1) x 8 + 5 x 5 = 5则以上两个矩阵的离散卷积结果为5，这就是矩阵A经过处理后得到的新矩阵M(2,2)的值。 在高斯模糊中，设模糊半径为n，则定义一个维数为2n+1的权值矩阵G，且G(i,j)=f(i-n-1,j-n-1)，类似于将一个直角坐标系放在了G的中点处，这就是μ=0的原因。此处的f是二维正态分布函数。然后求和，将矩阵的每个数除以这个和。求和的步骤是防止图片过亮或过暗。将得到的矩阵G代替B计算，其结果就是高斯模糊的结果 优化上述方法的效率较低，在介绍正态分布时，二维的正态分布函数是两个一维函数相乘得到的，这两个一维函数分别是f(x)和f(y)，f(x)代表水平方向，f(y)代表垂直方向。对于一个n维权值矩阵，用它来处理a*b尺寸的图片，如果用二维正态分布函数来计算，总共需要计算a*b*n*n=abn²次，及其繁琐。这时我们可以使用一维的正态分布函数，得出一个“权值列向量”，这个向量的作用类似权值矩阵，用这个列向量把图片横向处理，相当于f(x)，再用它把图片纵向处理，相当于f(y)，此时图片经过两次处理，相当于f(x)*f(y)，也可以达到二维正态分布的效果，而计算量仅仅是a*b*n+a*b*n=2abn，下降了一个数量级。该方法不详细介绍，将在代码中展示。 代码实现GaussianBlur类，算法的核心部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public final class GaussianBlur { private static final int precision = 10000; // 精度，由于返回的是int数组，精度较低，因此需要将所有值同时扩大数倍，可以理解为把小数点向右移动 private static final double E = 2.718281828459045;//自然常数e private static final double PI = 3.141592653589793;//圆周率 /** * 快速高斯模糊 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] GaussianBlur(int[][][] picture,int radius){ int i, j, x, R, G, B, proportion, subscript; int[] matrix = LinearNormalDistribution(radius,1.5); int width = picture[0].length, height = picture[0][0].length; int[][][] color_1 = new int[3][width][height]; // 用来存高斯模糊后的数据 int[][][] color_2 = new int[3][width][height]; // 临时存储纵向滤波之后的数据 //纵向滤波 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; height) ? x : 2 * j - x; // 如果坐标越界了，则计算对称点来代替 R += picture[0][i][subscript] * proportion; G += picture[1][i][subscript] * proportion; B += picture[2][i][subscript] * proportion; } color_2[0][i][j] = R / precision; color_2[1][i][j] = G / precision; color_2[2][i][j] = B / precision; } } //横向滤波 for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { R = G = B = 0; for (x = j - radius; x &lt;= j + radius; x++) { proportion = matrix[x + radius - j]; subscript = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * j - x; R += color_2[0][subscript][i] * proportion; G += color_2[1][subscript][i] * proportion; B += color_2[2][subscript][i] * proportion; } //注意for语句中i代表高度，j代表宽度，所以下面三个语句的i和j并没有写错位置 color_1[0][j][i] = R / precision; color_1[1][j][i] = G / precision; color_1[2][j][i] = B / precision; } } return color_1; } /** * 慢速高斯模糊，采用二维正态分布的方法来处理图像 * @param picture 三维数组,picture[a][b][c]，a表示颜色，012分别为R,G,B;b和c代表尺寸，宽度为b，高度为c * @param radius 半径 * @return 格式如同picture的数组 */ public static int[][][] SlowGaussianBlur(int[][][] picture,int radius){ //flag为真时计算加权，为假时直接代入矩阵 int[][] matrix = NormalDistribution(radius,1.5); int i, j, x, y, R, G, B, proportion, left, right, width = picture[0].length, height = picture[0][0].length; int[][][] color = new int[3][width][height]; //选取每个点 for (i = 0; i &lt; width; i++) { for (j = 0; j &lt; height; j++) { //选取半径为radius的矩阵 R = G = B = 0; for (x = i - radius; x &lt;= i + radius; x++) { for (y = j - radius; y &lt;= j + radius; y++) { //求出颜色 proportion = matrix[x + radius - i][y + radius - j]; left = (x &gt;= 0 &amp;&amp; x &lt; width) ? x : 2 * i - x; right = (y &gt;= 0 &amp;&amp; y &lt; height) ? y : 2 * j - y; R += picture[0][left][right] * proportion; G += picture[1][left][right] * proportion; B += picture[2][left][right] * proportion; } } color[0][i][j] = R / precision; color[1][i][j] = G / precision; color[2][i][j] = B / precision; } } return color; } /** * 用一维正态分布函数来计算“权值列向量”，效率较高 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return “权值列向量” */ private static int[] LinearNormalDistribution(int radius,double SIGMA){ int[] matrix = new int[2 * radius + 1]; // 定义一个列向量 int sum, i; //计算各个点的正态分布值 sum = matrix[radius] = (int) (precision / (2 * PI * SIGMA * SIGMA)); // sum的初值为向量中心点的值，例如向量(1,2,3,2,1)，则初值为3 for (i = 1; i &lt;= radius; i++) { //根据对称性，可以减少一倍的运算量，i=0的情况已经在sum初值那一步考虑 matrix[radius-i] = matrix[radius+i] = (int) ((Math.pow(E, -i * i / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA)) * precision); sum += matrix[radius+i] * 2; // 计算向量所有值之和 } for (i = 0; i &lt; 2 * radius + 1; i++) { matrix[i] = matrix[i] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } return matrix; } /** * 用二维正态分布函数来计算权值矩阵，效率较低 * @param radius 模糊半径 * @param SIGMA 正态分布参数，如果自己没把握，就填1.5 * @return 权值矩阵 */ private static int[][] NormalDistribution(int radius, double SIGMA) { int sum = 0, i, j; int[][] matrix = new int[2 * radius + 1][2 * radius + 1]; // 定义一个矩阵 //计算各个点的正态分布值 for (i = 0; i &lt;= radius; i++) { for (j = 0; j &lt;= radius; j++) { //写入矩阵并累加，根据矩阵的对称性可以减少3/4的运算量 matrix[radius-i][radius-j] = matrix[radius-i][radius+j] = matrix[radius+i][radius-j] = matrix[radius+i][radius+j] = (int) (Math.pow(E, -(i * i + j * j) / (2 * SIGMA * SIGMA)) / (2 * PI * SIGMA * SIGMA) * precision); sum += 4 * matrix[radius+i][radius+j]; } } //计算权值 for (i = 0; i &lt;= 2 * radius; i++) { for (j = 0; j &lt;= 2 * radius; j++) { matrix[i][j] = matrix[i][j] * precision / sum; // 所有值都除以sum，确保它们的和为“1”，由于扩大了10000倍，所以这个“1”实际上应该是10000 } } return matrix; }} Filter类，通过调用GaussianBlur类来处理图像 1234567891011121314151617181920212223242526272829303132333435import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException; public final class Filter { public static BufferedImage GaussianBlur(String path){ int pixel; try { BufferedImage image = ImageIO.read(new File(path)); int width = image.getWidth(),height = image.getHeight(); int[][][] picture = new int[3][width][height]; for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = image.getRGB(i,j); //获取每个点的RGB值 picture[0][i][j] = (pixel &amp; 0xff0000) &gt;&gt; 16; picture[1][i][j] = (pixel &amp; 0xff00) &gt;&gt; 8; picture[2][i][j] = (pixel &amp; 0xff); } } picture = GaussianBlur.GaussianBlur(picture,100); // 快速高斯模糊 for(int i=image.getMinX();i&lt;width;i++){ for(int j=image.getMinY();j&lt;height;j++){ pixel = ((picture[0][i][j] &amp; 0xff) &lt;&lt; 16) + ((picture[1][i][j] &amp; 0xff) &lt;&lt; 8) + (picture[2][i][j] &amp; 0xff); image.setRGB(i,j,pixel); } } return image; } catch (IOException e) { e.printStackTrace(); return null; } }} Main,打开1.jpg并高斯模糊，保存为2.jpg 1234567891011import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.File; public class Main { public static void main(String[] args) throws Exception{ BufferedImage image = Filter.GaussianBlur(\"D://1.jpg\"); ImageIO.write(image,\"jpg\",new File(\"D://2.jpg\")); }} 效果原图 高斯模糊之后的图(半径20，SIGMA1.5)源文件https://dearx.lanzoui.com/iSxBJr0uu6d","categories":[{"name":"图像算法","slug":"图像算法","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"DearXuan"}],"categories":[{"name":"XML","slug":"XML","permalink":"http://example.com/categories/XML/"},{"name":"启动参数","slug":"XML/启动参数","permalink":"http://example.com/categories/XML/%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"加密","slug":"算法/加密","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/"},{"name":"RSA","slug":"算法/加密/RSA","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/"},{"name":"硬件绑定","slug":"算法/加密/RSA/硬件绑定","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"name":"文件读写","slug":"算法/加密/RSA/硬件绑定/文件读写","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A0%E5%AF%86/RSA/%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"name":"敏感词过滤","slug":"算法/敏感词过滤","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"},{"name":"多叉树","slug":"算法/敏感词过滤/多叉树","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/%E5%A4%9A%E5%8F%89%E6%A0%91/"},{"name":"图像算法","slug":"图像算法","permalink":"http://example.com/categories/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}